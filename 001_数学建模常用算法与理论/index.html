<!DOCTYPE html>
<html lang="zh" >
<head>
    <meta charset="utf-8">
<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">


    <link rel="dns-prefetch" //cdn.jsdelivr.net>



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdui@1.0.2/dist/css/mdui.min.css">





<meta name="theme-color" content="#3F51B5">


<style>
    html,body{scroll-behavior:smooth;min-height:100vh}
    blockquote>strong>a{word-break:break-all}
    .mdui-hoverable:hover,.mdui-hoverable:focus{-webkit-box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12) !important;box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12) !important;}
    .mdui-card-primary-title a{text-decoration:none !important}
    .page-number{display:none !important}
    .mdui-container-fluid{transition:opacity .4s}
    
        body{background-color: #f6f6f6}

    
</style>
    
    <title>数学建模常用算法与理论 | Old Blogs</title>
    <link rel="canonical" href="https://Random-spike.github.io/Old-Blogs/Old-Blogs/001_%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B8%8E%E7%90%86%E8%AE%BA/">
    <meta name="description" content="本文同步自个人博客 here  全文基本具体的介绍了数学建模会可能使用到的数学工具和算法工具。 其中内容可能文字表述和公式表述较为复杂。可以访问 ChatGPT 在文本框复制难以理解的文章部分并在段落前加入： 1具象直观地解释这一段落内容。  来快速理解文章内容。 文章中有部分AI创作内容，可能会出现小纰漏，如有发现，望指出。 1 预测类用于根据已知数据推断未来的趋势和结果。 1.1 回归算法1">
<meta property="og:type" content="article">
<meta property="og:title" content="数学建模常用算法与理论">
<meta property="og:url" content="https://random-spike.github.io/Old-Blogs/001_%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B8%8E%E7%90%86%E8%AE%BA/index.html">
<meta property="og:site_name" content="Old Blogs">
<meta property="og:description" content="本文同步自个人博客 here  全文基本具体的介绍了数学建模会可能使用到的数学工具和算法工具。 其中内容可能文字表述和公式表述较为复杂。可以访问 ChatGPT 在文本框复制难以理解的文章部分并在段落前加入： 1具象直观地解释这一段落内容。  来快速理解文章内容。 文章中有部分AI创作内容，可能会出现小纰漏，如有发现，望指出。 1 预测类用于根据已知数据推断未来的趋势和结果。 1.1 回归算法1">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-11-02T02:33:05.000Z">
<meta property="article:modified_time" content="2025-11-30T09:29:38.425Z">
<meta property="article:author" content="Random-spike">
<meta name="twitter:card" content="summary">
<meta name="generator" content="Hexo 8.1.1"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head>
<body class="mdui-theme-primary-indigo mdui-theme-accent-pink mdui-appbar-with-toolbar ">
    <div class="mdui-theme-layout-light">
    <header id="appbar" class="mdui-appbar mdui-appbar-fixed mdui-shadow-0 mdui-appbar-scroll-hide">
    <div class="mdui-toolbar">
        <button mdui-drawer="{target: '.mdui-drawer'}" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon material-icons">menu</i></button>
        <a href="/Old-Blogs/" class="mdui-typo-title">Old Blogs</a>
        <div class="mdui-toolbar-spacer"></div>
        
        <a href="/Old-Blogs/search/" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon material-icons">search</i></a>
        
    </div>
</header>
    <aside class="mdui-drawer mdui-drawer-close">
    <nav class="mdui-list" mdui-collapse="{accordion: true}">
        <a href="/Old-Blogs/about/"  class="mdui-list-item mdui-ripple">
            <div class="mdui-list-item-avatar">
                
                <i class="mdui-color-theme-primary mdui-icon material-icons">person</i>
                
            </div>
            <div class="mdui-list-item-content">Random-spike</div>
        </a>
        <div class="mdui-divider"></div>
        
        <a href="/Old-Blogs/" class="mdui-list-item mdui-ripple">
            <i class="mdui-list-item-icon mdui-icon material-icons">home</i>
            <div class="mdui-list-item-content">主页</div>
        </a>
        
        <div class="mdui-collapse-item">
            <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
                <i class="mdui-list-item-icon mdui-icon material-icons">inbox</i>
                <div class="mdui-list-item-content">归档</div>
                <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
            </div>
            <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
                <a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2025/11/">十一月 2025</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2025/10/">十月 2025</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2025/03/">三月 2025</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2025/02/">二月 2025</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2024/12/">十二月 2024</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2024/11/">十一月 2024</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2024/10/">十月 2024</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2024/09/">九月 2024</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2024/08/">八月 2024</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2024/07/">七月 2024</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2024/06/">六月 2024</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2024/05/">五月 2024</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2024/04/">四月 2024</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2024/03/">三月 2024</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2024/02/">二月 2024</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2024/01/">一月 2024</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2023/12/">十二月 2023</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2023/11/">十一月 2023</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2023/10/">十月 2023</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2023/09/">九月 2023</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2023/08/">八月 2023</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2023/07/">七月 2023</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2023/06/">六月 2023</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2023/05/">五月 2023</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2023/04/">四月 2023</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2023/03/">三月 2023</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2023/02/">二月 2023</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2023/01/">一月 2023</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/archives/2022/12/">十二月 2022</a>
            </div>
        </div>
        
        <div class="mdui-collapse-item">
            <div class="mdui-collapse-item-header mdui-list-item mdui-ripple">
                <i class="mdui-list-item-icon mdui-icon material-icons">apps</i>
                <div class="mdui-list-item-content">分类</div>
                <i class="mdui-collapse-item-arrow mdui-icon material-icons">keyboard_arrow_down</i>
            </div>
            <div class="mdui-collapse-item-body mdui-list mdui-list-dense">
                <a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/categories/florr/">florr</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/categories/%E6%96%B0%E6%96%87/">新文</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/categories/%E6%97%A7%E6%96%87/">旧文</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/categories/%E6%9D%82%E6%96%87/">杂文</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/categories/%E7%94%9F%E6%B4%BB%E9%97%B4/">生活间</a><a class="mdui-list-item mdui-ripple m-link" href="/Old-Blogs/categories/%E9%A2%98%E8%A7%A3/">题解</a>
            </div>
        </div>
        
    </nav>
    <div class="mdui-divider"></div>
    <footer class="mdui-m-l-2 mdui-m-t-1 mdui-typo mdui-text-color-theme-disabled">
        <p class="mdui-m-b-0">
            
            ©
            2025 Random-spike<br>
            
            Powered by <a href="https://hexo.io/" rel="noreferrer" target="_blank">Hexo</a><br>
            
            Theme - <a href="https://github.com/kwaa/hexo-theme-m" rel="noreferrer" target="_blank"
                mdui-tooltip="{position:'right', content: 'by 藍+85CD'}">M</a></p>
            
    </footer>
</aside>
    </div>
    <div class="mdui-container-fluid mdui-center" style="max-width:720px">
        <article class="mdui-card mdui-hoverable mdui-shadow-1 mdui-m-y-2" style="opacity: 1; border-radius: 4px">
    
    <div class="mdui-card-primary mdui-ripple">
    <div class="mdui-card-primary-title">
        <a role="heading" aria-level="1" class="mdui-text-color-theme-text" >数学建模常用算法与理论</a>
        
        <small> <a class="mdui-text-color-theme-text category-link" href="/Old-Blogs/categories/%E6%96%B0%E6%96%87/">新文</a></small>
        
    </div>
    <div class="mdui-card-primary-subtitle mdui-typo">
        
        <span mdui-tooltip="{content:'创建时间：2025-11-02 10:33<br>最后更新时间：2025-11-30 05:29'}">2025-11-02 -</span>
        
            <span>/001_数学建模常用算法与理论/</span>
        
    </div>
</div>
    
    
    <div class="mdui-divider"></div>
    <div class="mdui-card-content mdui-typo">
        
        <blockquote>
<p>本文同步自个人博客 <a href="https://random-spike.github.io/Blog/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B8%8E%E7%90%86%E8%AE%BA/">here</a></p>
</blockquote>
<p>全文基本具体的介绍了数学建模会可能使用到的数学工具和算法工具。</p>
<p>其中内容可能文字表述和公式表述较为复杂。可以访问 <a target="_blank" rel="noopener" href="https://chatgpt.com/">ChatGPT</a> 在文本框复制难以理解的文章部分并在段落前加入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">具象直观地解释这一段落内容。</span><br></pre></td></tr></table></figure>

<p>来快速理解文章内容。</p>
<p>文章中有部分AI创作内容，可能会出现小纰漏，如有发现，望指出。</p>
<h1 id="1-预测类"><a href="#1-预测类" class="headerlink" title="1 预测类"></a>1 预测类</h1><p>用于根据已知数据推断未来的趋势和结果。</p>
<h2 id="1-1-回归算法"><a href="#1-1-回归算法" class="headerlink" title="1.1 回归算法"></a>1.1 回归算法</h2><h3 id="1-1-1-回归分析基本概念"><a href="#1-1-1-回归分析基本概念" class="headerlink" title="1.1.1 回归分析基本概念"></a>1.1.1 回归分析基本概念</h3><h4 id="1-1-1-1-核心定义"><a href="#1-1-1-1-核心定义" class="headerlink" title="1.1.1.1 核心定义"></a>1.1.1.1 核心定义</h4><p>回归分析是研究因变量（目标）与自变量（特征）之间关系的统计方法。基本公式为：<br>$$<br>Y &#x3D; f(X) + \varepsilon<br>$$</p>
<p>这个数学模型包含四个关键部分。因变量Y是我们想要预测或解释的目标，它可以是房价、销量、温度等任何我们关心的指标。自变量X是影响Y的因素，在房价预测中可能是面积、位置、房龄等。函数f(X)代表了X与Y之间的系统关系，这是回归分析的核心所在。误差项ε则包含了所有未被模型捕捉到的影响因素，如测量误差、遗漏变量等。</p>
<h4 id="1-1-1-2-主要用途"><a href="#1-1-1-2-主要用途" class="headerlink" title="1.1.1.2 主要用途"></a>1.1.1.2 主要用途</h4><p>在实际应用中，回归分析主要有三个作用。首先是关系识别，我们可以量化每个自变量对因变量的影响程度和方向，比如知道面积每增加一平米对房价的具体影响。其次是预测估计，建立模型后可以用新的自变量值来预测未知的因变量。最后是趋势分析，通过模型理解变量间的变化规律，为决策提供依据。</p>
<h3 id="1-1-2-多元线性回归"><a href="#1-1-2-多元线性回归" class="headerlink" title="1.1.2 多元线性回归"></a>1.1.2 多元线性回归</h3><h4 id="1-1-2-1-基本原理"><a href="#1-1-2-1-基本原理" class="headerlink" title="1.1.2.1 基本原理"></a>1.1.2.1 基本原理</h4><p>多元线性回归基于一个核心假设：因变量与多个自变量之间存在线性关系。这意味着每个自变量的单位变化对因变量的影响是恒定不变的。比如在房价模型中，我们假设面积每增加一平米对房价的贡献是固定的，不受其他因素影响。这种方法的优势在于模型简单易懂，而且计算效率高。</p>
<h4 id="1-1-2-2-数学模型"><a href="#1-1-2-2-数学模型" class="headerlink" title="1.1.2.2 数学模型"></a>1.1.2.2 数学模型</h4><p>$$<br>Y &#x3D; \beta_0 + \beta_1X_1 + \beta_2X_2 + \cdots + \beta_pX_p + \varepsilon<br>$$</p>
<p>在这个数学模型中，β₀被称为截距项，它代表了当所有自变量都为零时的基准水平。β₁到β_p是回归系数，每个系数表示对应自变量对因变量的边际效应。具体来说，在保持其他变量不变的情况下，某个自变量每变化一个单位，因变量平均会变化多少。误差项ε则包含了所有未被模型解释的随机因素。</p>
<h4 id="1-1-2-3-参数估计方法"><a href="#1-1-2-3-参数估计方法" class="headerlink" title="1.1.2.3 参数估计方法"></a>1.1.2.3 参数估计方法</h4><p>最小二乘法的核心思想很直观：找到一组参数估计值，使得所有观测值的预测误差平方和达到最小。这种方法在数学上有很好的性质，它给出的估计量是无偏的，而且在所有线性无偏估计量中方差最小。在实际计算中，我们通常通过矩阵运算来求解，这样可以同时得到所有参数的估计值。</p>
<h4 id="1-1-2-4-模型检验"><a href="#1-1-2-4-模型检验" class="headerlink" title="1.1.2.4 模型检验"></a>1.1.2.4 模型检验</h4><p>建立模型后需要进行严格的统计检验。R²决定系数告诉我们模型能够解释因变量变异的比例，但这个指标会随着自变量增加而虚假升高，因此我们更关注调整后的R²。对每个系数的t检验可以判断该自变量是否真的对因变量有显著影响，通常要求p值小于0.05。F检验则从整体上判断模型是否显著，即所有自变量联合起来是否对因变量有解释力。</p>
<h4 id="1-1-2-5-实例：房价预测分析"><a href="#1-1-2-5-实例：房价预测分析" class="headerlink" title="1.1.2.5 实例：房价预测分析"></a>1.1.2.5 实例：房价预测分析</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;面积&#x27;</span>: [<span class="number">80</span>, <span class="number">95</span>, <span class="number">110</span>, <span class="number">120</span>, <span class="number">135</span>, <span class="number">145</span>, <span class="number">160</span>],</span><br><span class="line">    <span class="string">&#x27;卧室数&#x27;</span>: [<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">    <span class="string">&#x27;房龄&#x27;</span>: [<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">12</span>],</span><br><span class="line">    <span class="string">&#x27;房价&#x27;</span>: [<span class="number">320</span>, <span class="number">420</span>, <span class="number">480</span>, <span class="number">520</span>, <span class="number">580</span>, <span class="number">620</span>, <span class="number">680</span>]</span><br><span class="line">&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立模型</span></span><br><span class="line">X = df[[<span class="string">&#x27;面积&#x27;</span>, <span class="string">&#x27;卧室数&#x27;</span>, <span class="string">&#x27;房龄&#x27;</span>]]</span><br><span class="line">y = df[<span class="string">&#x27;房价&#x27;</span>]</span><br><span class="line">X = sm.add_constant(X)  <span class="comment"># 添加截距项</span></span><br><span class="line"></span><br><span class="line">model = sm.OLS(y, X)</span><br><span class="line">results = model.fit()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(results.summary())</span><br></pre></td></tr></table></figure>

<h4 id="1-1-2-6-结果解读："><a href="#1-1-2-6-结果解读：" class="headerlink" title="1.1.2.6 结果解读："></a>1.1.2.6 结果解读：</h4><p>假设得到方程：房价 &#x3D; 50 + 3.1×面积 + 25×卧室数 - 8×房龄</p>
<p>这个结果具有明确的经济意义。面积系数3.1表示在卧室数和房龄不变的情况下，面积每增加1平米，房价平均上涨3.1万元。卧室系数25说明在面积和房龄不变时，每增加一间卧室，房价上涨25万元。房龄系数为负值符合常识，房龄每增加1年，房价下降8万元。如果模型的R²达到0.9以上，说明这三个变量能够很好地解释房价变化。</p>
<h3 id="1-1-3-多项式回归"><a href="#1-1-3-多项式回归" class="headerlink" title="1.1.3 多项式回归"></a>1.1.3 多项式回归</h3><h4 id="1-1-3-1-基本原理"><a href="#1-1-3-1-基本原理" class="headerlink" title="1.1.3.1 基本原理"></a>1.1.3.1 基本原理</h4><p>现实世界中的很多关系并不是简单的直线关系。多项式回归通过引入自变量的高次项，使得模型能够拟合曲线关系。这种方法的核心思想是用多项式函数来逼近真实的复杂关系。比如植物的生长速度通常是先快后慢，这种趋势用直线就无法很好描述，而二次函数就能更好地捕捉这种变化模式。</p>
<h4 id="1-1-3-2-数学模型"><a href="#1-1-3-2-数学模型" class="headerlink" title="1.1.3.2 数学模型"></a>1.1.3.2 数学模型</h4><p>$$<br>Y &#x3D; \beta_0 + \beta_1X + \beta_2X^2 + \cdots + \beta_kX^k + \varepsilon<br>$$</p>
<p>从数学角度看，多项式回归实际上是多元线性回归的一个特例。我们通过变量变换，将X的高次项视为新的自变量，这样就把非线性关系转化为了线性关系。比如二次多项式回归中，我们把X²看作第二个自变量，这样就可以用线性回归的方法来求解。这种转换使得我们既能够拟合复杂曲线，又能够利用成熟的线性回归理论。</p>
<h4 id="1-1-3-3-阶数选择"><a href="#1-1-3-3-阶数选择" class="headerlink" title="1.1.3.3 阶数选择"></a>1.1.3.3 阶数选择</h4><p>选择合适的多项式阶数是一个重要问题。阶数太低会导致欠拟合，模型过于简单无法捕捉数据中的真实模式。阶数太高又会导致过拟合，模型不仅学习了总体趋势，还学习了数据中的随机噪声，导致在新数据上表现很差。理想的方法是先从低阶开始，通过交叉验证选择在测试集上表现最好的模型。</p>
<h4 id="1-1-3-4-实例：植物生长分析"><a href="#1-1-3-4-实例：植物生长分析" class="headerlink" title="1.1.3.4 实例：植物生长分析"></a>1.1.3.4 实例：植物生长分析</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生长数据：时间(周) vs 高度(cm)</span></span><br><span class="line">时间 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br><span class="line">高度 = np.array([<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">11.5</span>, <span class="number">11.8</span>, <span class="number">12</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用2阶多项式</span></span><br><span class="line">poly = PolynomialFeatures(degree=<span class="number">2</span>)</span><br><span class="line">X_poly = poly.fit_transform(时间.reshape(-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">model = LinearRegression()</span><br><span class="line">model.fit(X_poly, 高度)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测和绘图</span></span><br><span class="line">X_fit = np.linspace(<span class="number">0</span>, <span class="number">9</span>, <span class="number">100</span>).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">X_fit_poly = poly.transform(X_fit)</span><br><span class="line">y_fit = model.predict(X_fit_poly)</span><br><span class="line"></span><br><span class="line">plt.scatter(时间, 高度, color=<span class="string">&#x27;blue&#x27;</span>, label=<span class="string">&#x27;实际数据&#x27;</span>)</span><br><span class="line">plt.plot(X_fit, y_fit, color=<span class="string">&#x27;red&#x27;</span>, label=<span class="string">&#x27;多项式拟合&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;时间（周）&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;高度（cm）&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h4 id="1-1-3-5-结果分析："><a href="#1-1-3-5-结果分析：" class="headerlink" title="1.1.3.5 结果分析："></a>1.1.3.5 结果分析：</h4><p>如果得到方程：高度 &#x3D; 1.5 + 3.2×时间 - 0.18×时间²</p>
<p>这个结果具有清晰的生物学意义。一次项系数3.2代表了初始生长速率，说明在最初几周，植物每周能长高约3.2厘米。二次项系数为负值（-0.18）反映了生长速率的衰减，随着时间推移，每周的生长量逐渐减少。这种先加速后减速的生长模式在植物学中很常见，多项式回归成功捕捉到了这一规律。</p>
<h3 id="1-1-4-逻辑回归"><a href="#1-1-4-逻辑回归" class="headerlink" title="1.1.4 逻辑回归"></a>1.1.4 逻辑回归</h3><h4 id="1-1-4-1-基本原理"><a href="#1-1-4-1-基本原理" class="headerlink" title="1.1.4.1 基本原理"></a>1.1.4.1 基本原理</h4><p>逻辑回归虽然名字中有”回归”，但实际上是一种分类算法。它的核心思想不是直接预测类别标签，而是估计样本属于某个类别的概率。这种方法特别适合处理二分类问题，如判断邮件是否为垃圾邮件、客户是否会违约等。逻辑回归通过Sigmoid函数将线性组合的结果映射到0到1之间，这个值可以解释为概率。</p>
<h4 id="1-1-4-2-数学模型"><a href="#1-1-4-2-数学模型" class="headerlink" title="1.1.4.2 数学模型"></a>1.1.4.2 数学模型</h4><p>$$<br>P(Y&#x3D;1) &#x3D; \frac{1}{1 + e^{-(\beta_0 + \beta_1X_1 + \cdots + \beta_pX_p)}}<br>$$</p>
<p>Sigmoid函数具有很好的数学性质，它能够将任何实数映射到(0,1)区间，正好符合概率的定义。当线性组合的结果趋近正无穷时，概率趋近于1；当线性组合趋近负无穷时，概率趋近于0。这种平滑的S形曲线使得模型在类别边界处的预测更加合理。</p>
<h4 id="1-1-4-3-结果解释"><a href="#1-1-4-3-结果解释" class="headerlink" title="1.1.4.3 结果解释"></a>1.1.4.3 结果解释</h4><p>逻辑回归系数的解释与线性回归不同。由于模型是非线性的，系数表示的是对几率比对数的影响。一个正系数意味着该自变量会增加样本属于正类的概率，负系数则相反。我们可以通过指数运算将系数转化为几率比，这样就能更直观地理解自变量的影响程度。</p>
<h4 id="1-1-4-4-实例：信用风险评估"><a href="#1-1-4-4-实例：信用风险评估" class="headerlink" title="1.1.4.4 实例：信用风险评估"></a>1.1.4.4 实例：信用风险评估</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> accuracy_score, confusion_matrix</span><br><span class="line"></span><br><span class="line"><span class="comment"># 信用数据</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;收入&#x27;</span>: [<span class="number">5000</span>, <span class="number">8000</span>, <span class="number">3000</span>, <span class="number">6000</span>, <span class="number">4000</span>, <span class="number">7000</span>, <span class="number">5500</span>, <span class="number">3500</span>],</span><br><span class="line">    <span class="string">&#x27;负债比&#x27;</span>: [<span class="number">0.2</span>, <span class="number">0.1</span>, <span class="number">0.6</span>, <span class="number">0.3</span>, <span class="number">0.5</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.7</span>],</span><br><span class="line">    <span class="string">&#x27;违约&#x27;</span>: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]  <span class="comment"># 0:不违约, 1:违约</span></span><br><span class="line">&#125;</span><br><span class="line">df = pd.DataFrame(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立逻辑回归模型</span></span><br><span class="line">X = df[[<span class="string">&#x27;收入&#x27;</span>, <span class="string">&#x27;负债比&#x27;</span>]]</span><br><span class="line">y = df[<span class="string">&#x27;违约&#x27;</span>]</span><br><span class="line"></span><br><span class="line">model = LogisticRegression()</span><br><span class="line">model.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测</span></span><br><span class="line">y_pred = model.predict(X)</span><br><span class="line">y_prob = model.predict_proba(X)[:, <span class="number">1</span>]  <span class="comment"># 预测为1类的概率</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;准确率: <span class="subst">&#123;accuracy_score(y, y_pred):<span class="number">.3</span>f&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;混淆矩阵:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(confusion_matrix(y, y_pred))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;系数: <span class="subst">&#123;model.coef_&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;截距: <span class="subst">&#123;model.intercept_&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="1-1-4-5-结果解读："><a href="#1-1-4-5-结果解读：" class="headerlink" title="1.1.4.5 结果解读："></a>1.1.4.5 结果解读：</h4><p>假设得到方程：logit(P) &#x3D; -2.1 + 0.0003×收入 - 4.2×负债比</p>
<p>这个结果在风险管理中很有实用价值。收入系数为正值说明收入越高，违约概率越低，这符合我们的常识。负债比系数为负值表明负债比例越高，违约风险越大。银行可以利用这个模型计算每个客户的违约概率，比如设定0.5为阈值，概率高于0.5的客户需要更严格的审核。这种数据驱动的方法比主观判断更加科学可靠。</p>
<h3 id="1-1-5-方法对比与选择指南"><a href="#1-1-5-方法对比与选择指南" class="headerlink" title="1.1.5 方法对比与选择指南"></a>1.1.5 方法对比与选择指南</h3><h4 id="1-1-5-1-适用场景总结"><a href="#1-1-5-1-适用场景总结" class="headerlink" title="1.1.5.1 适用场景总结"></a>1.1.5.1 适用场景总结</h4><p>三种回归方法各有其适用领域。多元线性回归最适合预测连续的数值型结果，如房价、销量等，要求自变量与因变量之间存在线性关系。多项式回归扩展了线性回归的能力，能够处理曲线关系，如生长曲线、物理定律等。逻辑回归专门用于二分类问题，在风险评估、医疗诊断等领域应用广泛。</p>
<h4 id="1-1-5-2-选择流程"><a href="#1-1-5-2-选择流程" class="headerlink" title="1.1.5.2 选择流程"></a>1.1.5.2 选择流程</h4><p>在实际建模时，建议遵循系统化的选择流程。首先要明确分析目标，是预测具体数值还是进行分类。接着通过可视化工具探索数据特征，观察变量间的关系模式。然后从简单模型开始尝试，逐步增加复杂度。最后要验证模型效果，不仅要看统计指标，还要确保结果有实际意义。</p>
<h4 id="1-1-5-3-实践建议"><a href="#1-1-5-3-实践建议" class="headerlink" title="1.1.5.3 实践建议"></a>1.1.5.3 实践建议</h4><p>成功的回归分析需要兼顾理论和方法。图形化分析是必不可少的第一步，它能帮助我们直观理解数据特征。模型解释性很重要，特别是需要向非技术人员说明结果时。要避免过度追求复杂的模型，有时候简单模型的效果更好且更稳健。最重要的是，模型结果要能够结合领域知识来理解，纯粹的数据驱动往往不够。</p>
<h2 id="1-2-时间序列分析实用指南"><a href="#1-2-时间序列分析实用指南" class="headerlink" title="1.2 时间序列分析实用指南"></a>1.2 时间序列分析实用指南</h2><h3 id="1-2-1-基本概念"><a href="#1-2-1-基本概念" class="headerlink" title="1.2.1 基本概念"></a>1.2.1 基本概念</h3><h4 id="1-2-1-1-时间序列是按时间顺序排列的数据点序列："><a href="#1-2-1-1-时间序列是按时间顺序排列的数据点序列：" class="headerlink" title="1.2.1.1 时间序列是按时间顺序排列的数据点序列："></a>1.2.1.1 时间序列是按时间顺序排列的数据点序列：</h4><p>$$<br>{X_t} &#x3D; {X_1, X_2, \ldots, X_T}<br>$$</p>
<h4 id="1-2-1-2-核心组成成分"><a href="#1-2-1-2-核心组成成分" class="headerlink" title="1.2.1.2 核心组成成分"></a>1.2.1.2 核心组成成分</h4><h4 id="1-2-1-3-加法模型（最常用）："><a href="#1-2-1-3-加法模型（最常用）：" class="headerlink" title="1.2.1.3 加法模型（最常用）："></a>1.2.1.3 加法模型（最常用）：</h4><p>$$<br>X_t &#x3D; T_t + S_t + R_t<br>$$</p>
<ul>
<li>$T_t$：趋势成分 - 长期发展方向</li>
<li>$S_t$：季节成分 - 固定周期的重复模式</li>
<li>$R_t$：随机成分 - 不可预测的波动</li>
</ul>
<h3 id="1-2-2-平稳性：建模的基础"><a href="#1-2-2-平稳性：建模的基础" class="headerlink" title="1.2.2 平稳性：建模的基础"></a>1.2.2 平稳性：建模的基础</h3><h4 id="1-2-2-1-为什么要平稳？"><a href="#1-2-2-1-为什么要平稳？" class="headerlink" title="1.2.2.1 为什么要平稳？"></a>1.2.2.1 为什么要平稳？</h4><p>平稳时间序列的统计特性不随时间变化，这是ARIMA模型的基础假设。</p>
<h4 id="1-2-2-2-平稳性检验（ADF检验）："><a href="#1-2-2-2-平稳性检验（ADF检验）：" class="headerlink" title="1.2.2.2 平稳性检验（ADF检验）："></a>1.2.2.2 平稳性检验（ADF检验）：</h4><ul>
<li>原假设 $H_0$：序列非平稳</li>
<li>备择假设 $H_1$：序列平稳</li>
<li>判断标准：p值 &lt; 0.05 表示序列平稳</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> statsmodels.tsa.stattools <span class="keyword">import</span> adfuller</span><br><span class="line"></span><br><span class="line">result = adfuller(data)</span><br><span class="line">p_value = result[<span class="number">1</span>]</span><br><span class="line">is_stationary = p_value &lt; <span class="number">0.05</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-3-如何使数据平稳？"><a href="#1-2-2-3-如何使数据平稳？" class="headerlink" title="1.2.2.3 如何使数据平稳？"></a>1.2.2.3 如何使数据平稳？</h4><p>如果数据不平稳，使用差分：<br>$$<br>\nabla X_t &#x3D; X_t - X_{t-1}<br>$$</p>
<p>一次差分不行就二次差分，直到ADF检验通过。</p>
<h3 id="1-2-3-ARIMA模型核心思想"><a href="#1-2-3-ARIMA模型核心思想" class="headerlink" title="1.2.3 ARIMA模型核心思想"></a>1.2.3 ARIMA模型核心思想</h3><p>ARIMA$(p,d,q)$ 包含三个部分：</p>
<h4 id="1-2-3-1-自回归-AR-部分"><a href="#1-2-3-1-自回归-AR-部分" class="headerlink" title="1.2.3.1 自回归(AR)部分"></a>1.2.3.1 自回归(AR)部分</h4><p>用历史值预测当前值：<br>$$<br>X_t &#x3D; c + \phi_1 X_{t-1} + \phi_2 X_{t-2} + \cdots + \phi_p X_{t-p} + \varepsilon_t<br>$$</p>
<h4 id="1-2-3-2-移动平均-MA-部分"><a href="#1-2-3-2-移动平均-MA-部分" class="headerlink" title="1.2.3.2 移动平均(MA)部分"></a>1.2.3.2 移动平均(MA)部分</h4><p>用历史预测误差改进预测：<br>$$<br>X_t &#x3D; \mu + \varepsilon_t + \theta_1 \varepsilon_{t-1} + \theta_2 \varepsilon_{t-2} + \cdots + \theta_q \varepsilon_{t-q}<br>$$</p>
<h4 id="1-2-3-3-差分-I-部分"><a href="#1-2-3-3-差分-I-部分" class="headerlink" title="1.2.3.3 差分(I)部分"></a>1.2.3.3 差分(I)部分</h4><p>通过 $d$ 阶差分使数据平稳。</p>
<h4 id="1-2-3-4-完整ARIMA模型："><a href="#1-2-3-4-完整ARIMA模型：" class="headerlink" title="1.2.3.4 完整ARIMA模型："></a>1.2.3.4 完整ARIMA模型：</h4><p>$$<br>(1-\phi_1B-\cdots-\phi_pB^p)(1-B)^d X_t &#x3D; c + (1+\theta_1B+\cdots+\theta_qB^q)\varepsilon_t<br>$$</p>
<h3 id="1-2-4-步建模法"><a href="#1-2-4-步建模法" class="headerlink" title="1.2.4 步建模法"></a>1.2.4 步建模法</h3><h4 id="1-2-4-1-步骤1：观察数据"><a href="#1-2-4-1-步骤1：观察数据" class="headerlink" title="1.2.4.1 步骤1：观察数据"></a>1.2.4.1 步骤1：观察数据</h4><p>画出时间序列图，直观感受趋势和季节性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.plot(data)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h4 id="1-2-4-2-步骤2：检验平稳性"><a href="#1-2-4-2-步骤2：检验平稳性" class="headerlink" title="1.2.4.2 步骤2：检验平稳性"></a>1.2.4.2 步骤2：检验平稳性</h4><p>用ADF检验，如果p值 &gt; 0.05，进行差分。</p>
<h4 id="1-2-4-3-步骤3：确定参数-p-d-q"><a href="#1-2-4-3-步骤3：确定参数-p-d-q" class="headerlink" title="1.2.4.3 步骤3：确定参数(p,d,q)"></a>1.2.4.3 步骤3：确定参数(p,d,q)</h4><h4 id="1-2-4-4-简单规则："><a href="#1-2-4-4-简单规则：" class="headerlink" title="1.2.4.4 简单规则："></a>1.2.4.4 简单规则：</h4><ul>
<li>d：差分的次数（使数据平稳）</li>
<li>p：看PACF图，在哪个滞后阶数后截尾</li>
<li>q：看ACF图，在哪个滞后阶数后截尾</li>
</ul>
<h4 id="1-2-4-5-实用建议："><a href="#1-2-4-5-实用建议：" class="headerlink" title="1.2.4.5 实用建议："></a>1.2.4.5 实用建议：</h4><p>从ARIMA(1,1,1)开始尝试。</p>
<h4 id="1-2-4-6-步骤4：建立模型"><a href="#1-2-4-6-步骤4：建立模型" class="headerlink" title="1.2.4.6 步骤4：建立模型"></a>1.2.4.6 步骤4：建立模型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> statsmodels.tsa.arima.model <span class="keyword">import</span> ARIMA</span><br><span class="line"></span><br><span class="line">model = ARIMA(data, order=(<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">results = model.fit()</span><br></pre></td></tr></table></figure>

<h4 id="1-2-4-7-步骤5：模型诊断"><a href="#1-2-4-7-步骤5：模型诊断" class="headerlink" title="1.2.4.7 步骤5：模型诊断"></a>1.2.4.7 步骤5：模型诊断</h4><p>检查残差是否为白噪声：</p>
<ul>
<li>残差应该在0附近随机波动</li>
<li>无明显的自相关性</li>
</ul>
<h3 id="1-2-5-模型选择：AIC准则"><a href="#1-2-5-模型选择：AIC准则" class="headerlink" title="1.2.5 模型选择：AIC准则"></a>1.2.5 模型选择：AIC准则</h3><h4 id="1-2-5-1-AIC值越小，模型越好："><a href="#1-2-5-1-AIC值越小，模型越好：" class="headerlink" title="1.2.5.1 AIC值越小，模型越好："></a>1.2.5.1 AIC值越小，模型越好：</h4><p>$$<br>\text{AIC} &#x3D; 2k - 2\ln(L)<br>$$</p>
<p>$k$是参数个数，$L$是似然函数值。</p>
<h3 id="1-2-6-预测与不确定性"><a href="#1-2-6-预测与不确定性" class="headerlink" title="1.2.6 预测与不确定性"></a>1.2.6 预测与不确定性</h3><h4 id="1-2-6-1-点预测"><a href="#1-2-6-1-点预测" class="headerlink" title="1.2.6.1 点预测"></a>1.2.6.1 点预测</h4><p>给出未来最可能的值。</p>
<h4 id="1-2-6-2-区间预测"><a href="#1-2-6-2-区间预测" class="headerlink" title="1.2.6.2 区间预测"></a>1.2.6.2 区间预测</h4><p>95%置信区间表示真实值有95%的概率落在这个范围内。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 预测未来7天</span></span><br><span class="line">forecast = results.get_forecast(steps=<span class="number">7</span>)</span><br><span class="line">mean = forecast.predicted_mean          <span class="comment"># 点预测</span></span><br><span class="line">conf_int = forecast.conf_int()          <span class="comment"># 置信区间</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-7-实战案例：奶茶店销量预测"><a href="#1-2-7-实战案例：奶茶店销量预测" class="headerlink" title="1.2.7 实战案例：奶茶店销量预测"></a>1.2.7 实战案例：奶茶店销量预测</h3><h4 id="1-2-7-1-问题背景"><a href="#1-2-7-1-问题背景" class="headerlink" title="1.2.7.1 问题背景"></a>1.2.7.1 问题背景</h4><p>小王有60天奶茶销量数据，想预测未来7天销量。</p>
<h4 id="1-2-7-2-建模过程"><a href="#1-2-7-2-建模过程" class="headerlink" title="1.2.7.2 建模过程"></a>1.2.7.2 建模过程</h4><ol>
<li>数据探索：发现明显上升趋势和每周周期性</li>
<li>平稳性检验：p值&#x3D;0.22 &gt; 0.05，需要差分</li>
<li>一阶差分：p值&#x3D;0.000001 &lt; 0.05，数据平稳</li>
<li>建立模型：选择ARIMA(1,1,1)，AIC&#x3D;345.67</li>
<li>模型诊断：残差是白噪声，模型合适</li>
</ol>
<h4 id="1-2-7-3-预测结果"><a href="#1-2-7-3-预测结果" class="headerlink" title="1.2.7.3 预测结果"></a>1.2.7.3 预测结果</h4><div class="mdui-table-fluid mdui-shadow-0"><table class="mdui-table mdui-table-hoverable">
<thead>
<tr>
<th>天数</th>
<th>预测销量</th>
<th>95%置信区间</th>
</tr>
</thead>
<tbody><tr>
<td>第1天</td>
<td>128.5杯</td>
<td>112.3-144.7杯</td>
</tr>
<tr>
<td>第2天</td>
<td>126.8杯</td>
<td>106.9-146.7杯</td>
</tr>
</tbody></table></div>
<h3 id="1-2-8-模型评估指标"><a href="#1-2-8-模型评估指标" class="headerlink" title="1.2.8 模型评估指标"></a>1.2.8 模型评估指标</h3><h4 id="1-2-8-1-MAPE（推荐使用）："><a href="#1-2-8-1-MAPE（推荐使用）：" class="headerlink" title="1.2.8.1 MAPE（推荐使用）："></a>1.2.8.1 MAPE（推荐使用）：</h4><p>$$<br>\text{MAPE} &#x3D; \frac{100%}{n}\sum \left|\frac{\text{实际值}-\text{预测值}}{\text{实际值}}\right|<br>$$</p>
<h4 id="1-2-8-2-评估标准："><a href="#1-2-8-2-评估标准：" class="headerlink" title="1.2.8.2 评估标准："></a>1.2.8.2 评估标准：</h4><ul>
<li>MAPE &lt; 10%：优秀</li>
<li>10% &lt; MAPE &lt; 20%：良好</li>
<li>MAPE &gt; 20%：需要改进</li>
</ul>
<h3 id="1-2-9-季节性ARIMA（SARIMA）"><a href="#1-2-9-季节性ARIMA（SARIMA）" class="headerlink" title="1.2.9 季节性ARIMA（SARIMA）"></a>1.2.9 季节性ARIMA（SARIMA）</h3><p>如果数据有明显的季节性（如月度、季度数据），使用SARIMA模型。</p>
<h4 id="1-2-9-1-模型表示："><a href="#1-2-9-1-模型表示：" class="headerlink" title="1.2.9.1 模型表示："></a>1.2.9.1 模型表示：</h4><p>SARIMA$(p,d,q)\times(P,D,Q)_s$</p>
<ul>
<li>$s$：季节周期（月度数据s&#x3D;12，季度数据s&#x3D;4）</li>
<li>$(P,D,Q)$：季节性部分的参数</li>
</ul>
<h3 id="1-2-10-注意要点"><a href="#1-2-10-注意要点" class="headerlink" title="1.2.10 注意要点"></a>1.2.10 注意要点</h3><h4 id="1-2-10-1-开始时的选择"><a href="#1-2-10-1-开始时的选择" class="headerlink" title="1.2.10.1 开始时的选择"></a>1.2.10.1 开始时的选择</h4><ol>
<li>从 ARIMA(1,1,1) 开始尝试</li>
<li>如果效果不好，用AIC准则比较不同参数组合</li>
<li>优先选择简单的模型</li>
</ol>
<h4 id="1-2-10-2-避免常见错误"><a href="#1-2-10-2-避免常见错误" class="headerlink" title="1.2.10.2 避免常见错误"></a>1.2.10.2 避免常见错误</h4><ol>
<li>不要跳过平稳性检验：这是建模的基础</li>
<li>不要过度追求复杂模型：简单模型往往更稳健</li>
<li>一定要检查残差：确保模型充分提取信息</li>
</ol>
<h3 id="1-2-11-总结"><a href="#1-2-11-总结" class="headerlink" title="1.2.11 总结"></a>1.2.11 总结</h3><p>时间序列分析的核心思想是”用历史预测未来”。通过系统的五步法：观察→平稳化→建模→诊断→预测，可以建立可靠的预测模型。</p>
<h4 id="1-2-11-1-关键点："><a href="#1-2-11-1-关键点：" class="headerlink" title="1.2.11.1 关键点："></a>1.2.11.1 关键点：</h4><ol>
<li>数据必须平稳才能用ARIMA</li>
<li>从简单模型开始尝试</li>
<li>用AIC选择最佳模型</li>
<li>预测时要给出置信区间</li>
<li>结合业务理解解释结果</li>
</ol>
<p>时间序列分析虽然有一定的数学复杂度，但遵循这个实用指南，你就能建立有效的预测模型，为决策提供数据支持。</p>
<h1 id="2-评价类"><a href="#2-评价类" class="headerlink" title="2 评价类"></a>2 评价类</h1><p>用于对多个对象（方案、个体等）进行综合优劣排序或等级评定。</p>
<h2 id="2-1-AHP层次分析法"><a href="#2-1-AHP层次分析法" class="headerlink" title="2.1 AHP层次分析法"></a>2.1 AHP层次分析法</h2><h3 id="2-1-1-方法核心"><a href="#2-1-1-方法核心" class="headerlink" title="2.1.1 方法核心"></a>2.1.1 方法核心</h3><p>层次分析法通过构造层次化结构，将决策问题分解为目标、准则和方案三个层次。其数学本质是通过求解判断矩阵的特征向量来确定各元素的相对权重。</p>
<p>设决策问题包含 $n$ 个准则 $C_1, C_2, \dots, C_n$，我们需要确定它们对目标的相对重要性权重 $w_1, w_2, \dots, w_n$，其中：</p>
<p>$$<br>\sum_{i&#x3D;1}^n w_i &#x3D; 1,\quad w_i &gt; 0<br>$$</p>
<h3 id="2-1-2-判断矩阵构造"><a href="#2-1-2-判断矩阵构造" class="headerlink" title="2.1.2 判断矩阵构造"></a>2.1.2 判断矩阵构造</h3><p>通过两两比较构造判断矩阵 $A$：</p>
<p>$$<br>A &#x3D; \begin{pmatrix}<br>a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \<br>a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \<br>\vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}<br>\end{pmatrix}<br>$$</p>
<p>其中 $a_{ij}$ 表示准则 $C_i$ 相对于 $C_j$ 的重要性比值，满足：</p>
<p>$$<br>a_{ij} &#x3D; \frac{1}{a_{ji}},\quad a_{ii} &#x3D; 1<br>$$</p>
<h4 id="2-1-2-1-标度定义："><a href="#2-1-2-1-标度定义：" class="headerlink" title="2.1.2.1 标度定义："></a>2.1.2.1 标度定义：</h4><ul>
<li>$1$：同等重要</li>
<li>$3$：稍微重要  </li>
<li>$5$：明显重要</li>
<li>$7$：强烈重要</li>
<li>$9$：极端重要</li>
<li>$2,4,6,8$：中间值</li>
</ul>
<h3 id="2-1-3-权重计算"><a href="#2-1-3-权重计算" class="headerlink" title="2.1.3 权重计算"></a>2.1.3 权重计算</h3><h4 id="2-1-3-1-特征向量法"><a href="#2-1-3-1-特征向量法" class="headerlink" title="2.1.3.1 特征向量法"></a>2.1.3.1 特征向量法</h4><p>理论上，权重向量 $W &#x3D; (w_1, w_2, \dots, w_n)^T$ 应满足：</p>
<p>$$<br>AW &#x3D; \lambda_{max}W<br>$$</p>
<p>其中 $\lambda_{max}$ 是矩阵 $A$ 的最大特征值。</p>
<h4 id="2-1-3-2-近似算法（几何平均法）"><a href="#2-1-3-2-近似算法（几何平均法）" class="headerlink" title="2.1.3.2 近似算法（几何平均法）"></a>2.1.3.2 近似算法（几何平均法）</h4><p>在实际应用中，常采用几何平均法进行近似计算：</p>
<h4 id="2-1-3-3-步骤1：计算每行元素的几何平均值"><a href="#2-1-3-3-步骤1：计算每行元素的几何平均值" class="headerlink" title="2.1.3.3 步骤1：计算每行元素的几何平均值"></a>2.1.3.3 步骤1：计算每行元素的几何平均值</h4><p>$$<br>m_i &#x3D; \left(\prod_{j&#x3D;1}^n a_{ij}\right)^{1&#x2F;n}<br>$$</p>
<h4 id="2-1-3-4-步骤2：对-m-i-进行归一化得到权重"><a href="#2-1-3-4-步骤2：对-m-i-进行归一化得到权重" class="headerlink" title="2.1.3.4 步骤2：对 $m_i$ 进行归一化得到权重"></a>2.1.3.4 步骤2：对 $m_i$ 进行归一化得到权重</h4><p>$$<br>w_i &#x3D; \frac{m_i}{\sum_{j&#x3D;1}^n m_j}<br>$$</p>
<h3 id="2-1-4-致性检验"><a href="#2-1-4-致性检验" class="headerlink" title="2.1.4 致性检验"></a>2.1.4 致性检验</h3><p>一致性指标定义为：</p>
<p>$$<br>CI &#x3D; \frac{\lambda_{max} - n}{n - 1}<br>$$</p>
<p>其中 $\lambda_{max}$ 可通过下式近似计算：</p>
<p>$$<br>\lambda_{max} &#x3D; \frac{1}{n}\sum_{i&#x3D;1}^n \frac{(AW)_i}{w_i}<br>$$</p>
<p>一致性比率为：</p>
<p>$$<br>CR &#x3D; \frac{CI}{RI}<br>$$</p>
<p>$RI$ 为随机一致性指标（Random Index）：</p>
<div class="mdui-table-fluid mdui-shadow-0"><table class="mdui-table mdui-table-hoverable">
<thead>
<tr>
<th>$n$</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>$RI$</td>
<td>0</td>
<td>0</td>
<td>0.52</td>
<td>0.89</td>
<td>1.12</td>
<td>1.26</td>
<td>1.36</td>
<td>1.41</td>
<td>1.46</td>
</tr>
</tbody></table></div>
<h4 id="2-1-4-1-检验标准：当-CR-0-10-时，认为判断矩阵的一致性可以接受。"><a href="#2-1-4-1-检验标准：当-CR-0-10-时，认为判断矩阵的一致性可以接受。" class="headerlink" title="2.1.4.1 检验标准：当 $CR &lt; 0.10$ 时，认为判断矩阵的一致性可以接受。"></a>2.1.4.1 检验标准：当 $CR &lt; 0.10$ 时，认为判断矩阵的一致性可以接受。</h4><h3 id="2-1-5-算法实现"><a href="#2-1-5-算法实现" class="headerlink" title="2.1.5 算法实现"></a>2.1.5 算法实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AHP</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, comparison_matrix</span>):</span><br><span class="line">        <span class="variable language_">self</span>.A = np.array(comparison_matrix)</span><br><span class="line">        <span class="variable language_">self</span>.n = <span class="variable language_">self</span>.A.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="variable language_">self</span>.RI = &#123;<span class="number">1</span>:<span class="number">0</span>, <span class="number">2</span>:<span class="number">0</span>, <span class="number">3</span>:<span class="number">0.52</span>, <span class="number">4</span>:<span class="number">0.89</span>, <span class="number">5</span>:<span class="number">1.12</span>, <span class="number">6</span>:<span class="number">1.26</span>, <span class="number">7</span>:<span class="number">1.36</span>, <span class="number">8</span>:<span class="number">1.41</span>, <span class="number">9</span>:<span class="number">1.46</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate_weights</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 几何平均法计算权重</span></span><br><span class="line">        geometric_means = np.prod(<span class="variable language_">self</span>.A, axis=<span class="number">1</span>)  (<span class="number">1</span>/<span class="variable language_">self</span>.n)</span><br><span class="line">        weights = geometric_means / np.<span class="built_in">sum</span>(geometric_means)</span><br><span class="line">        <span class="keyword">return</span> weights</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">consistency_check</span>(<span class="params">self, weights</span>):</span><br><span class="line">        <span class="comment"># 计算最大特征值</span></span><br><span class="line">        AW = np.dot(<span class="variable language_">self</span>.A, weights)</span><br><span class="line">        lambda_max = np.mean(AW / weights)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 一致性指标</span></span><br><span class="line">        CI = (lambda_max - <span class="variable language_">self</span>.n) / (<span class="variable language_">self</span>.n - <span class="number">1</span>)</span><br><span class="line">        CR = CI / <span class="variable language_">self</span>.RI[<span class="variable language_">self</span>.n]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> lambda_max, CI, CR</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">analyze</span>(<span class="params">self</span>):</span><br><span class="line">        weights = <span class="variable language_">self</span>.calculate_weights()</span><br><span class="line">        lambda_max, CI, CR = <span class="variable language_">self</span>.consistency_check(weights)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;判断矩阵:&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.A)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;\n权重向量: <span class="subst">&#123;weights&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;最大特征值: <span class="subst">&#123;lambda_max:<span class="number">.4</span>f&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;一致性指标 CI: <span class="subst">&#123;CI:<span class="number">.4</span>f&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;一致性比率 CR: <span class="subst">&#123;CR:<span class="number">.4</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> CR &lt; <span class="number">0.1</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;✓ 一致性检验通过&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;✗ 一致性检验未通过，需要调整判断矩阵&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> weights, CR</span><br></pre></td></tr></table></figure>

<h3 id="2-1-6-应用示例"><a href="#2-1-6-应用示例" class="headerlink" title="2.1.6 应用示例"></a>2.1.6 应用示例</h3><p>考虑笔记本电脑选购问题，准则包括：价格(C1)、性能(C2)、外观(C3)、品牌(C4)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 判断矩阵</span></span><br><span class="line">comparison_matrix = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>/<span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>],      <span class="comment"># 价格 vs 其他</span></span><br><span class="line">    [<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>],        <span class="comment"># 性能 vs 其他  </span></span><br><span class="line">    [<span class="number">1</span>/<span class="number">3</span>, <span class="number">1</span>/<span class="number">5</span>, <span class="number">1</span>, <span class="number">1</span>/<span class="number">2</span>],  <span class="comment"># 外观 vs 其他</span></span><br><span class="line">    [<span class="number">1</span>/<span class="number">2</span>, <span class="number">1</span>/<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>]     <span class="comment"># 品牌 vs 其他</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行分析</span></span><br><span class="line">ahp = AHP(comparison_matrix)</span><br><span class="line">weights, cr = ahp.analyze()</span><br></pre></td></tr></table></figure>

<h4 id="2-1-6-1-输出结果："><a href="#2-1-6-1-输出结果：" class="headerlink" title="2.1.6.1 输出结果："></a>2.1.6.1 输出结果：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">判断矩阵:</span><br><span class="line">[[1.         0.33333333 3.         2.        ]</span><br><span class="line"> [3.         1.         5.         4.        ]</span><br><span class="line"> [0.33333333 0.2        1.         0.5       ]</span><br><span class="line"> [0.5        0.25       2.         1.        ]]</span><br><span class="line"></span><br><span class="line">权重向量: [0.245 0.476 0.086 0.193]</span><br><span class="line">最大特征值: 4.0512</span><br><span class="line">一致性指标 CI: 0.0171</span><br><span class="line">一致性比率 CR: 0.0190</span><br><span class="line">✓ 一致性检验通过</span><br></pre></td></tr></table></figure>

<h3 id="2-1-7-层次总排序"><a href="#2-1-7-层次总排序" class="headerlink" title="2.1.7 层次总排序"></a>2.1.7 层次总排序</h3><p>设第 $k$ 个准则的权重为 $w_k$，方案 $S_i$ 在第 $k$ 个准则下的权重为 $v_i^k$，则方案总得分为：</p>
<p>$$<br>Score(S_i) &#x3D; \sum_{k&#x3D;1}^n w_k \cdot v_i^k<br>$$</p>
<p>最优方案为：</p>
<p>$$<br>S^* &#x3D; \arg\max_i Score(S_i)<br>$$</p>
<h3 id="2-1-8-方法评价"><a href="#2-1-8-方法评价" class="headerlink" title="2.1.8 方法评价"></a>2.1.8 方法评价</h3><h4 id="2-1-8-1-优势："><a href="#2-1-8-1-优势：" class="headerlink" title="2.1.8.1 优势："></a>2.1.8.1 优势：</h4><ul>
<li>结构清晰，易于理解</li>
<li>将定性判断定量化</li>
<li>提供一致性检验机制</li>
</ul>
<h4 id="2-1-8-2-局限："><a href="#2-1-8-2-局限：" class="headerlink" title="2.1.8.2 局限："></a>2.1.8.2 局限：</h4><ul>
<li>判断矩阵的主观性</li>
<li>不适用于元素过多的情况</li>
<li>对判断矩阵的变化敏感</li>
</ul>
<h2 id="2-2-熵权法"><a href="#2-2-熵权法" class="headerlink" title="2.2 熵权法"></a>2.2 熵权法</h2><h3 id="2-2-1-方法核心思想"><a href="#2-2-1-方法核心思想" class="headerlink" title="2.2.1 方法核心思想"></a>2.2.1 方法核心思想</h3><p>熵权法是一种客观赋权法。其基本思想源于信息论：</p>
<blockquote>
<p>信息的多少（信息熵）是系统无序程度的度量。</p>
</blockquote>
<p>对于一个指标：</p>
<ul>
<li>若其内部数据差异越大，则它提供的信息量越大，其熵越小，该指标的权重就应越大</li>
<li>若所有样本在该指标上的值完全相同，则该指标不提供任何信息量，其熵最大，权重应为零</li>
</ul>
<h4 id="2-2-1-1-直观理解："><a href="#2-2-1-1-直观理解：" class="headerlink" title="2.2.1.1 直观理解："></a>2.2.1.1 直观理解：</h4><p>它寻找的是在现有数据中区分能力最强的指标。</p>
<h3 id="2-2-2-算法实现步骤"><a href="#2-2-2-算法实现步骤" class="headerlink" title="2.2.2 算法实现步骤"></a>2.2.2 算法实现步骤</h3><p>假设有 $m$ 个样本，$n$ 个评价指标，形成原始数据矩阵 $\mathbf{X} &#x3D; (x_{ij})_{m \times n}$。</p>
<h4 id="2-2-2-1-第一步：数据预处理"><a href="#2-2-2-1-第一步：数据预处理" class="headerlink" title="2.2.2.1 第一步：数据预处理"></a>2.2.2.1 第一步：数据预处理</h4><h4 id="2-2-2-2-a-正向化"><a href="#2-2-2-2-a-正向化" class="headerlink" title="2.2.2.2 a) 正向化"></a>2.2.2.2 a) 正向化</h4><p>将所有指标转化为极大型指标（数值越大越好）。</p>
<ul>
<li><p>极小型指标（如成本）：</p>
<p>$$<br>x_{ij}’ &#x3D; \max(x_j) - x_{ij}<br>$$</p>
</li>
<li><p>中间型指标：</p>
<p>$$<br>x_{ij}’ &#x3D; 1 - \frac{|x_{ij} - x_{\text{best}}|}{\max(|x_{ij} - x_{\text{best}}|)}<br>$$</p>
</li>
<li><p>区间型指标：需根据具体区间进行转换</p>
</li>
</ul>
<h4 id="2-2-2-3-b-标准化（归一化）"><a href="#2-2-2-3-b-标准化（归一化）" class="headerlink" title="2.2.2.3 b) 标准化（归一化）"></a>2.2.2.3 b) 标准化（归一化）</h4><p>采用比重法，消除量纲，计算每个样本在指标下的比重：<br>$$<br>p_{ij} &#x3D; \frac{x_{ij}}{\sum_{i&#x3D;1}^{m} x_{ij}}<br>$$<br>确保 $\sum_{i&#x3D;1}^{m} p_{ij} &#x3D; 1$。若存在负数或零，需进行非负化平移。</p>
<h4 id="2-2-2-4-第二步：计算各指标的信息熵"><a href="#2-2-2-4-第二步：计算各指标的信息熵" class="headerlink" title="2.2.2.4 第二步：计算各指标的信息熵"></a>2.2.2.4 第二步：计算各指标的信息熵</h4><p>第 $j$ 个指标的信息熵 $e_j$ 计算公式为：<br>$$<br>e_j &#x3D; -k \sum_{i&#x3D;1}^{m} p_{ij} \ln(p_{ij})<br>$$<br>其中，$k &#x3D; 1 &#x2F; \ln(m) &gt; 0$，用于保证 $0 \le e_j \le 1$。</p>
<blockquote>
<p>计算注意：当 $p_{ij} &#x3D; 0$ 时，规定 $0 \cdot \ln(0) &#x3D; 0$。代码实现中可用极小值（如 <code>1e-10</code>）替代0。</p>
</blockquote>
<h4 id="2-2-2-5-第三步：计算信息效用值（差异系数）"><a href="#2-2-2-5-第三步：计算信息效用值（差异系数）" class="headerlink" title="2.2.2.5 第三步：计算信息效用值（差异系数）"></a>2.2.2.5 第三步：计算信息效用值（差异系数）</h4><p>信息熵 $e_j$ 的补数即为信息效用值 $d_j$：<br>$$<br>d_j &#x3D; 1 - e_j<br>$$<br>$d_j$ 越大，表明该指标提供的信息量越大，越重要。</p>
<h4 id="2-2-2-6-第四步：确定权重"><a href="#2-2-2-6-第四步：确定权重" class="headerlink" title="2.2.2.6 第四步：确定权重"></a>2.2.2.6 第四步：确定权重</h4><p>将信息效用值归一化，得到每个指标的熵权 $w_j$：<br>$$<br>w_j &#x3D; \frac{d_j}{\sum_{j&#x3D;1}^{n} d_j}<br>$$<br>最终得到权重向量 $\mathbf{W} &#x3D; (w_1, w_2, …, w_n)$，满足 $\sum_{j&#x3D;1}^{n} w_j &#x3D; 1$。</p>
<h3 id="2-2-3-案例与代码实现"><a href="#2-2-3-案例与代码实现" class="headerlink" title="2.2.3 案例与代码实现"></a>2.2.3 案例与代码实现</h3><h4 id="2-2-3-1-案例背景：三好学生评选"><a href="#2-2-3-1-案例背景：三好学生评选" class="headerlink" title="2.2.3.1 案例背景：三好学生评选"></a>2.2.3.1 案例背景：三好学生评选</h4><div class="mdui-table-fluid mdui-shadow-0"><table class="mdui-table mdui-table-hoverable">
<thead>
<tr>
<th align="left">学生</th>
<th align="left">成绩 ($X_1$)</th>
<th align="left">纪律得分 ($X_2$)</th>
<th align="left">班干部数量 ($X_3$)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">小明</td>
<td align="left">90</td>
<td align="left">1</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">小红</td>
<td align="left">80</td>
<td align="left">2</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">小刚</td>
<td align="left">70</td>
<td align="left">3</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">小丽</td>
<td align="left">60</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody></table></div>
<h4 id="2-2-3-2-Python-代码"><a href="#2-2-3-2-Python-代码" class="headerlink" title="2.2.3.2 Python 代码"></a>2.2.3.2 Python 代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">entropy_weight</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算指标的熵权</span></span><br><span class="line"><span class="string">    :param data: DataFrame，行为样本，列为指标。所有指标必须为正向指标且非负。</span></span><br><span class="line"><span class="string">    :return: 权重向量</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 步骤1：数据标准化 (比重法)</span></span><br><span class="line">    data = data / data.<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤2：计算信息熵</span></span><br><span class="line">    data = data.replace(<span class="number">0</span>, <span class="number">1e-10</span>) <span class="comment"># 避免log(0)</span></span><br><span class="line">    m = data.shape[<span class="number">0</span>]</span><br><span class="line">    k = <span class="number">1.0</span> / np.log(m)</span><br><span class="line">    e = -k * (data * np.log(data)).<span class="built_in">sum</span>(axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 步骤3 &amp; 4：计算权重</span></span><br><span class="line">    d = <span class="number">1</span> - e</span><br><span class="line">    w = d / d.<span class="built_in">sum</span>()</span><br><span class="line">    <span class="keyword">return</span> w.values</span><br><span class="line"></span><br><span class="line"><span class="comment"># 案例应用</span></span><br><span class="line">data_df = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;成绩&#x27;</span>: [<span class="number">90</span>, <span class="number">80</span>, <span class="number">70</span>, <span class="number">60</span>],</span><br><span class="line">    <span class="string">&#x27;纪律得分&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>],</span><br><span class="line">    <span class="string">&#x27;班干部数量&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>]</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;原始数据矩阵：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(data_df)</span><br><span class="line"></span><br><span class="line">weights = entropy_weight(data_df)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n各指标熵权：&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> col, w <span class="keyword">in</span> <span class="built_in">zip</span>(data_df.columns, weights):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;- <span class="subst">&#123;col&#125;</span>: <span class="subst">&#123;w:<span class="number">.4</span>f&#125;</span> (<span class="subst">&#123;w*<span class="number">100</span>:<span class="number">.2</span>f&#125;</span>%)&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-3-结果分析"><a href="#2-2-3-3-结果分析" class="headerlink" title="2.2.3.3 结果分析"></a>2.2.3.3 结果分析</h4><p>运行代码将得到类似结果：</p>
<ul>
<li>成绩：约 0.02 (2%)</li>
<li>纪律得分：约 0.49 (49%)</li>
<li>班干部数量：约 0.49 (49%)</li>
</ul>
<h4 id="2-2-3-4-结果解读："><a href="#2-2-3-4-结果解读：" class="headerlink" title="2.2.3.4 结果解读："></a>2.2.3.4 结果解读：</h4><p>此结果凸显了熵权法的特性。由于”纪律得分”和”班干部数量”的数据出现了极端值（0和3），内部差异巨大，因此被赋予了极高的权重。而”成绩”数据变化相对均匀，区分度较小，故权重极低。这一结果可能违背常识，说明需结合领域知识进行判断。</p>
<h3 id="2-2-4-熵权法与层次分析法-AHP-的对比"><a href="#2-2-4-熵权法与层次分析法-AHP-的对比" class="headerlink" title="2.2.4 熵权法与层次分析法(AHP)的对比"></a>2.2.4 熵权法与层次分析法(AHP)的对比</h3><div class="mdui-table-fluid mdui-shadow-0"><table class="mdui-table mdui-table-hoverable">
<thead>
<tr>
<th align="left">特征</th>
<th align="left">熵权法 (EWM)</th>
<th align="left">层次分析法 (AHP)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">核心原理</td>
<td align="left">数据驱动，基于指标内部数据的变异程度</td>
<td align="left">经验驱动，基于决策者的主观判断</td>
</tr>
<tr>
<td align="left">权重来源</td>
<td align="left">数据本身</td>
<td align="left">专家经验或决策者偏好</td>
</tr>
<tr>
<td align="left">客观性</td>
<td align="left">高</td>
<td align="left">低</td>
</tr>
<tr>
<td align="left">稳定性</td>
<td align="left">低（数据变化，权重即变）</td>
<td align="left">高（理念不变，权重稳定）</td>
</tr>
<tr>
<td align="left">计算复杂度</td>
<td align="left">低（公式固定，计算简单）</td>
<td align="left">高（需构造判断矩阵、一致性检验）</td>
</tr>
<tr>
<td align="left">适用场景</td>
<td align="left">1. 纯粹的数值比较问题<br>2. 无先验知识的新领域探索<br>3. 需要客观基准的场合</td>
<td align="left">1. 涉及价值判断的决策问题<br>2. 有明确标准或常识的领域（如教育、医疗）<br>3. 需要结合专家经验的战略规划</td>
</tr>
<tr>
<td align="left">在本案例的表现</td>
<td align="left">得出”成绩权重仅2%”的反常识结果</td>
<td align="left">可得出”成绩权重约60%”的符合常识的结果</td>
</tr>
</tbody></table></div>
<h3 id="2-2-5-实践建议与工作流程"><a href="#2-2-5-实践建议与工作流程" class="headerlink" title="2.2.5 实践建议与工作流程"></a>2.2.5 实践建议与工作流程</h3><h4 id="2-2-5-1-何时使用熵权法？"><a href="#2-2-5-1-何时使用熵权法？" class="headerlink" title="2.2.5.1 何时使用熵权法？"></a>2.2.5.1 何时使用熵权法？</h4><ul>
<li>当你需要一个完全由数据说话的客观权重时</li>
<li>作为探索性数据分析(EDA)的一部分，了解哪些指标在现有数据中具有区分力</li>
<li>作为主观赋权法（如AHP）的参考或校正基准</li>
</ul>
<h4 id="2-2-5-2-推荐的工作流程"><a href="#2-2-5-2-推荐的工作流程" class="headerlink" title="2.2.5.2 推荐的工作流程"></a>2.2.5.2 推荐的工作流程</h4><ol>
<li>数据预处理：确保数据清洁，完成正向化和非负化</li>
<li>计算熵权：运行熵权法代码，获得客观权重 $W_e$</li>
<li>领域知识评估：审视熵权结果，判断其是否符合业务逻辑<ul>
<li>若符合，可直接使用</li>
<li>若不符合（如本案例），则需引入主观权重 $W_s$（可通过AHP、专家打分等获得）</li>
</ul>
</li>
<li>权重合成（可选）：将主客观权重结合<br>$$<br>W_{\text{final}} &#x3D; \alpha W_s + (1-\alpha) W_e, \quad \alpha \in [0, 1]<br>$$<br>其中 $\alpha$ 反映了对主观经验的信赖程度</li>
</ol>
<h4 id="2-2-5-3-注意事项"><a href="#2-2-5-3-注意事项" class="headerlink" title="2.2.5.3 注意事项"></a>2.2.5.3 注意事项</h4><ul>
<li>数据质量：熵权法对极端值和数据分布非常敏感</li>
<li>指标相关性：该方法未考虑指标间的相关性，若指标高度相关，可能导致权重分配失真</li>
<li>结果解释：务必结合实际问题背景解读结果，切忌盲目相信数值输出</li>
<li></li>
</ul>
<h1 id="3-优化类"><a href="#3-优化类" class="headerlink" title="3 优化类"></a>3 优化类</h1><p>在给定约束条件下，寻找使目标函数达到最优（最大或最小）的决策。</p>
<h2 id="3-1-最优化算法在数学建模中的应用指南"><a href="#3-1-最优化算法在数学建模中的应用指南" class="headerlink" title="3.1 最优化算法在数学建模中的应用指南"></a>3.1 最优化算法在数学建模中的应用指南</h2><p>在实际的数学建模过程中，我们经常需要在满足特定约束条件的前提下，寻找使目标函数达到最优的决策方案。无论是资源分配、路径规划还是生产调度，优化算法都扮演着至关重要的角色。本文系统介绍三种经典的优化算法，每种算法均从理论原理、数学表达和实际应用三个维度进行深入剖析，帮助读者在面对具体问题时能够选择合适的方法并有效实施。</p>
<h2 id="3-2-线性规划：精确优化的基础工具"><a href="#3-2-线性规划：精确优化的基础工具" class="headerlink" title="3.2 线性规划：精确优化的基础工具"></a>3.2 线性规划：精确优化的基础工具</h2><h3 id="3-2-1-算法原理阐述"><a href="#3-2-1-算法原理阐述" class="headerlink" title="3.2.1 算法原理阐述"></a>3.2.1 算法原理阐述</h3><p>线性规划是解决资源分配问题的基础方法，适用于目标函数和约束条件均为线性的优化场景。其核心思想基于一个重要的几何事实：在由线性不等式约束构成的凸多面体可行域中，最优解必然出现在某个顶点上。</p>
<h4 id="3-2-1-1-算法运行机制："><a href="#3-2-1-1-算法运行机制：" class="headerlink" title="3.2.1.1 算法运行机制："></a>3.2.1.1 算法运行机制：</h4><p>单纯形法是求解线性规划最经典的算法，它从初始可行解出发，沿着可行域的边界从一个顶点移动到相邻顶点，每次移动都保证目标函数值得到改进，直到找到最优顶点。这个过程类似于在崎岖的山地上寻找最高点，通过系统性地检查所有可能的高地来确保找到真正的顶峰。</p>
<h4 id="3-2-1-2-方法优势分析："><a href="#3-2-1-2-方法优势分析：" class="headerlink" title="3.2.1.2 方法优势分析："></a>3.2.1.2 方法优势分析：</h4><p>线性规划的主要优势在于其求解的精确性和可靠性。对于大规模线性规划问题，现代求解器可以在合理时间内找到全局最优解，这使其成为处理确定性优化问题的首选方法。</p>
<h3 id="3-2-2-数学模型构建"><a href="#3-2-2-数学模型构建" class="headerlink" title="3.2.2 数学模型构建"></a>3.2.2 数学模型构建</h3><p>标准线性规划问题的数学表达如下：</p>
<p>$$<br>\begin{aligned}<br>\min \quad &amp; \mathbf{c}^T \mathbf{x} \<br>\text{s.t.} \quad &amp; A\mathbf{x} \leq \mathbf{b} \<br>&amp; \mathbf{x} \geq \mathbf{0}<br>\end{aligned}<br>$$</p>
<p>其中各个符号的含义为：</p>
<ul>
<li>$\mathbf{x} &#x3D; (x_1, x_2, \ldots, x_n)^T$：决策变量向量，代表需要优化的各个决策因素</li>
<li>$\mathbf{c} \in \mathbb{R}^n$：目标函数系数向量，表示各个决策变量对目标的贡献程度</li>
<li>$A \in \mathbb{R}^{m \times n}$：约束系数矩阵，描述资源消耗或技术关系</li>
<li>$\mathbf{b} \in \mathbb{R}^m$：资源约束向量，表示可用资源的上限</li>
</ul>
<p>对于整数规划问题，需额外添加约束条件$x_i \in \mathbb{Z}$，表示决策变量必须取整数值。这在处理离散决策时尤为重要，如设备台数、人员数量等。</p>
<h3 id="3-2-3-算法实现代码"><a href="#3-2-3-算法实现代码" class="headerlink" title="3.2.3 算法实现代码"></a>3.2.3 算法实现代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pulp</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">linear_programming_example</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    生产计划优化问题实例</span></span><br><span class="line"><span class="string">    目标：在资源约束下最大化利润</span></span><br><span class="line"><span class="string">    问题描述：</span></span><br><span class="line"><span class="string">      工厂生产两种产品A和B</span></span><br><span class="line"><span class="string">      - 产品A：利润80元/件，耗时2小时，耗料4单位</span></span><br><span class="line"><span class="string">      - 产品B：利润60元/件，耗时3小时，耗料2单位</span></span><br><span class="line"><span class="string">      资源限制：</span></span><br><span class="line"><span class="string">      - 每日可用工时：100小时</span></span><br><span class="line"><span class="string">      - 每日可用原料：80单位</span></span><br><span class="line"><span class="string">      - 市场需求：产品A不超过30件，产品B不超过20件</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 创建优化问题，指定问题名称和优化方向（最大化）</span></span><br><span class="line">    prob = pulp.LpProblem(<span class="string">&quot;Production_Planning&quot;</span>, pulp.LpMaximize)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义决策变量</span></span><br><span class="line">    <span class="comment"># x1: 产品A的日产量，下限0，上限30，整数约束</span></span><br><span class="line">    <span class="comment"># x2: 产品B的日产量，下限0，上限20，整数约束</span></span><br><span class="line">    x1 = pulp.LpVariable(<span class="string">&quot;Product_A&quot;</span>, lowBound=<span class="number">0</span>, upBound=<span class="number">30</span>, cat=<span class="string">&#x27;Integer&#x27;</span>)</span><br><span class="line">    x2 = pulp.LpVariable(<span class="string">&quot;Product_B&quot;</span>, lowBound=<span class="number">0</span>, upBound=<span class="number">20</span>, cat=<span class="string">&#x27;Integer&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置目标函数：最大化总利润</span></span><br><span class="line">    prob += <span class="number">80</span>*x1 + <span class="number">60</span>*x2, <span class="string">&quot;Total_Profit&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 添加约束条件</span></span><br><span class="line">    prob += <span class="number">2</span>*x1 + <span class="number">3</span>*x2 &lt;= <span class="number">100</span>, <span class="string">&quot;Labor_Constraint&quot;</span>    <span class="comment"># 工时约束</span></span><br><span class="line">    prob += <span class="number">4</span>*x1 + <span class="number">2</span>*x2 &lt;= <span class="number">80</span>, <span class="string">&quot;Material_Constraint&quot;</span>  <span class="comment"># 材料约束</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 求解问题</span></span><br><span class="line">    prob.solve()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 输出结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;线性规划求解结果：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;求解状态: <span class="subst">&#123;pulp.LpStatus[prob.status]&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;最优解: 生产产品A <span class="subst">&#123;x1.varValue&#125;</span> 件，产品B <span class="subst">&#123;x2.varValue&#125;</span> 件&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;最大利润: <span class="subst">&#123;pulp.value(prob.objective)&#125;</span> 元&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;工时资源使用: <span class="subst">&#123;<span class="number">2</span>*x1.varValue + <span class="number">3</span>*x2.varValue&#125;</span> / 100 小时&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;材料资源使用: <span class="subst">&#123;<span class="number">4</span>*x1.varValue + <span class="number">2</span>*x2.varValue&#125;</span> / 80 单位&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x1.varValue, x2.varValue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行示例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    optimal_A, optimal_B = linear_programming_example()</span><br></pre></td></tr></table></figure>

<h3 id="3-2-4-实际应用案例"><a href="#3-2-4-实际应用案例" class="headerlink" title="3.2.4 实际应用案例"></a>3.2.4 实际应用案例</h3><h4 id="3-2-4-1-案例背景："><a href="#3-2-4-1-案例背景：" class="headerlink" title="3.2.4.1 案例背景："></a>3.2.4.1 案例背景：</h4><p>某制造企业需要制定下月的生产计划，现有两条生产线，分别生产普通产品和高级产品。普通产品每件利润为50元，高级产品每件利润为80元。生产普通产品需要2个工时和3单位原材料，生产高级产品需要4个工时和2单位原材料。每月可用工时为160小时，原材料为120单位。市场调查显示，高级产品月需求量不超过30件。</p>
<h4 id="3-2-4-2-数学模型建立："><a href="#3-2-4-2-数学模型建立：" class="headerlink" title="3.2.4.2 数学模型建立："></a>3.2.4.2 数学模型建立：</h4><p>设$x_1$为普通产品产量，$x_2$为高级产品产量，建立如下模型：</p>
<p>$$<br>\begin{aligned}<br>\max \quad &amp; 50x_1 + 80x_2 \<br>\text{s.t.} \quad &amp; 2x_1 + 4x_2 \leq 160 \<br>&amp; 3x_1 + 2x_2 \leq 120 \<br>&amp; x_2 \leq 30 \<br>&amp; x_1, x_2 \geq 0, \quad x_1, x_2 \in \mathbb{Z}<br>\end{aligned}<br>$$</p>
<h4 id="3-2-4-3-求解分析："><a href="#3-2-4-3-求解分析：" class="headerlink" title="3.2.4.3 求解分析："></a>3.2.4.3 求解分析：</h4><p>通过线性规划求解得到最优生产计划为：普通产品20件，高级产品30件，最大利润为3400元。此时工时资源完全利用（2×20 + 4×30 &#x3D; 160），原材料使用100单位（3×20 + 2×30 &#x3D; 120），高级产品达到市场需求的饱和点。</p>
<h2 id="3-3-遗传算法：仿生优化的智能方法"><a href="#3-3-遗传算法：仿生优化的智能方法" class="headerlink" title="3.3 遗传算法：仿生优化的智能方法"></a>3.3 遗传算法：仿生优化的智能方法</h2><h3 id="3-3-1-算法原理阐述"><a href="#3-3-1-算法原理阐述" class="headerlink" title="3.3.1 算法原理阐述"></a>3.3.1 算法原理阐述</h3><p>遗传算法是模拟自然界生物进化过程的随机优化算法，其核心思想源于达尔文的自然选择学说和孟德尔的遗传变异理论。算法通过模拟”适者生存”的进化机制，在解空间中并行搜索最优解。</p>
<h4 id="3-3-1-1-算法运行流程："><a href="#3-3-1-1-算法运行流程：" class="headerlink" title="3.3.1.1 算法运行流程："></a>3.3.1.1 算法运行流程：</h4><p>遗传算法维护一个候选解群体（种群），每个个体代表一个潜在解。算法通过选择、交叉、变异等遗传操作，不断产生新一代种群，逐步逼近问题的最优解。这个过程模拟了自然界中种群的进化过程，优秀个体的基因特征在种群中得以保留和传播。</p>
<h4 id="3-3-1-2-方法优势分析："><a href="#3-3-1-2-方法优势分析：" class="headerlink" title="3.3.1.2 方法优势分析："></a>3.3.1.2 方法优势分析：</h4><p>遗传算法的主要优势在于其全局搜索能力和对问题性质的弱依赖性。它不要求目标函数具有可微、连续等良好数学性质，能够处理高度非线性和多峰优化问题，特别适合传统方法难以处理的复杂优化场景。</p>
<h3 id="3-3-2-数学模型构建"><a href="#3-3-2-数学模型构建" class="headerlink" title="3.3.2 数学模型构建"></a>3.3.2 数学模型构建</h3><p>遗传算法的数学基础可以表示为：</p>
<p>$$<br>P(t+1) &#x3D; \text{Mutation}(\text{Crossover}(\text{Selection}(P(t))))<br>$$</p>
<p>其中$P(t)$表示第$t$代种群。关键操作包括：</p>
<h4 id="3-3-2-1-选择操作：基于适应度的概率选择"><a href="#3-3-2-1-选择操作：基于适应度的概率选择" class="headerlink" title="3.3.2.1 选择操作：基于适应度的概率选择"></a>3.3.2.1 选择操作：基于适应度的概率选择</h4><p>$$<br>P_{\text{select}}(x_i) &#x3D; \frac{f(x_i)}{\sum_{j&#x3D;1}^{N} f(x_j)}<br>$$</p>
<h4 id="3-3-2-2-交叉操作：通过重组父代基因产生子代"><a href="#3-3-2-2-交叉操作：通过重组父代基因产生子代" class="headerlink" title="3.3.2.2 交叉操作：通过重组父代基因产生子代"></a>3.3.2.2 交叉操作：通过重组父代基因产生子代</h4><p>$$<br>\text{Child} &#x3D; \text{Recombine}(\text{Parent}_1, \text{Parent}_2)<br>$$</p>
<h4 id="3-3-2-3-变异操作：以小概率随机改变个体基因"><a href="#3-3-2-3-变异操作：以小概率随机改变个体基因" class="headerlink" title="3.3.2.3 变异操作：以小概率随机改变个体基因"></a>3.3.2.3 变异操作：以小概率随机改变个体基因</h4><p>$$<br>x_i^{\text{new}} &#x3D; x_i + \mathcal{N}(0, \sigma)<br>$$</p>
<p>算法的收敛性由模式定理保证，该定理表明高于平均适应度的模式在种群中呈指数增长。</p>
<h3 id="3-3-3-算法实现代码"><a href="#3-3-3-算法实现代码" class="headerlink" title="3.3.3 算法实现代码"></a>3.3.3 算法实现代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Tuple</span>, <span class="type">Callable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GeneticAlgorithm</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    遗传算法实现类</span></span><br><span class="line"><span class="string">    用于解决函数优化问题</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, population_size: <span class="built_in">int</span>, mutation_rate: <span class="built_in">float</span>, </span></span><br><span class="line"><span class="params">                 crossover_rate: <span class="built_in">float</span>, generations: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.population_size = population_size</span><br><span class="line">        <span class="variable language_">self</span>.mutation_rate = mutation_rate</span><br><span class="line">        <span class="variable language_">self</span>.crossover_rate = crossover_rate</span><br><span class="line">        <span class="variable language_">self</span>.generations = generations</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">initialize_population</span>(<span class="params">self, bounds: <span class="type">List</span>[<span class="type">Tuple</span>[<span class="built_in">float</span>, <span class="built_in">float</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">float</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;初始化种群，在给定边界内随机生成个体&quot;&quot;&quot;</span></span><br><span class="line">        population = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.population_size):</span><br><span class="line">            individual = [random.uniform(low, high) <span class="keyword">for</span> low, high <span class="keyword">in</span> bounds]</span><br><span class="line">            population.append(individual)</span><br><span class="line">        <span class="keyword">return</span> population</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">evaluate_fitness</span>(<span class="params">self, population: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">float</span>]], </span></span><br><span class="line"><span class="params">                        fitness_func: <span class="type">Callable</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;评估种群中每个个体的适应度&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> [fitness_func(ind) <span class="keyword">for</span> ind <span class="keyword">in</span> population]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">selection</span>(<span class="params">self, population: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">float</span>]], </span></span><br><span class="line"><span class="params">                 fitnesses: <span class="type">List</span>[<span class="built_in">float</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">float</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;锦标赛选择操作&quot;&quot;&quot;</span></span><br><span class="line">        selected = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(population)):</span><br><span class="line">            <span class="comment"># 随机选择3个个体进行锦标赛</span></span><br><span class="line">            tournament_indices = random.sample(<span class="built_in">range</span>(<span class="built_in">len</span>(population)), <span class="number">3</span>)</span><br><span class="line">            tournament_fitness = [fitnesses[i] <span class="keyword">for</span> i <span class="keyword">in</span> tournament_indices]</span><br><span class="line">            winner_idx = tournament_indices[np.argmax(tournament_fitness)]</span><br><span class="line">            selected.append(population[winner_idx])</span><br><span class="line">        <span class="keyword">return</span> selected</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">crossover</span>(<span class="params">self, parent1: <span class="type">List</span>[<span class="built_in">float</span>], parent2: <span class="type">List</span>[<span class="built_in">float</span>]</span>) -&gt; <span class="type">Tuple</span>[<span class="type">List</span>[<span class="built_in">float</span>]]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;算术交叉操作&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> random.random() &lt; <span class="variable language_">self</span>.crossover_rate:</span><br><span class="line">            alpha = random.random()</span><br><span class="line">            child1 = [alpha * p1 + (<span class="number">1</span> - alpha) * p2 <span class="keyword">for</span> p1, p2 <span class="keyword">in</span> <span class="built_in">zip</span>(parent1, parent2)]</span><br><span class="line">            child2 = [alpha * p2 + (<span class="number">1</span> - alpha) * p1 <span class="keyword">for</span> p1, p2 <span class="keyword">in</span> <span class="built_in">zip</span>(parent1, parent2)]</span><br><span class="line">            <span class="keyword">return</span> child1, child2</span><br><span class="line">        <span class="keyword">return</span> parent1, parent2</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mutation</span>(<span class="params">self, individual: <span class="type">List</span>[<span class="built_in">float</span>], bounds: <span class="type">List</span>[<span class="type">Tuple</span>[<span class="built_in">float</span>, <span class="built_in">float</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">float</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;高斯变异操作&quot;&quot;&quot;</span></span><br><span class="line">        mutated = individual.copy()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(mutated)):</span><br><span class="line">            <span class="keyword">if</span> random.random() &lt; <span class="variable language_">self</span>.mutation_rate:</span><br><span class="line">                low, high = bounds[i]</span><br><span class="line">                <span class="comment"># 在当前值基础上添加高斯噪声</span></span><br><span class="line">                mutated[i] += random.gauss(<span class="number">0</span>, (high - low) * <span class="number">0.1</span>)</span><br><span class="line">                <span class="comment"># 确保变异后的值仍在边界内</span></span><br><span class="line">                mutated[i] = <span class="built_in">max</span>(low, <span class="built_in">min</span>(high, mutated[i]))</span><br><span class="line">        <span class="keyword">return</span> mutated</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, fitness_func: <span class="type">Callable</span>, bounds: <span class="type">List</span>[<span class="type">Tuple</span>[<span class="built_in">float</span>, <span class="built_in">float</span>]]</span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;运行遗传算法&quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 初始化</span></span><br><span class="line">        population = <span class="variable language_">self</span>.initialize_population(bounds)</span><br><span class="line">        best_individual = <span class="literal">None</span></span><br><span class="line">        best_fitness = -<span class="built_in">float</span>(<span class="string">&#x27;inf&#x27;</span>)</span><br><span class="line">        fitness_history = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> generation <span class="keyword">in</span> <span class="built_in">range</span>(<span class="variable language_">self</span>.generations):</span><br><span class="line">            <span class="comment"># 评估适应度</span></span><br><span class="line">            fitnesses = <span class="variable language_">self</span>.evaluate_fitness(population, fitness_func)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 更新历史最佳</span></span><br><span class="line">            current_best_fitness = <span class="built_in">max</span>(fitnesses)</span><br><span class="line">            <span class="keyword">if</span> current_best_fitness &gt; best_fitness:</span><br><span class="line">                best_fitness = current_best_fitness</span><br><span class="line">                best_individual = population[np.argmax(fitnesses)]</span><br><span class="line">            </span><br><span class="line">            fitness_history.append(best_fitness)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 遗传操作</span></span><br><span class="line">            selected = <span class="variable language_">self</span>.selection(population, fitnesses)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 交叉</span></span><br><span class="line">            new_population = []</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(selected), <span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> i + <span class="number">1</span> &lt; <span class="built_in">len</span>(selected):</span><br><span class="line">                    child1, child2 = <span class="variable language_">self</span>.crossover(selected[i], selected[i+<span class="number">1</span>])</span><br><span class="line">                    new_population.extend([child1, child2])</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    new_population.append(selected[i])</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 变异</span></span><br><span class="line">            population = [<span class="variable language_">self</span>.mutation(ind, bounds) <span class="keyword">for</span> ind <span class="keyword">in</span> new_population]</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 输出进度</span></span><br><span class="line">            <span class="keyword">if</span> generation % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Generation <span class="subst">&#123;generation&#125;</span>: Best Fitness = <span class="subst">&#123;best_fitness:<span class="number">.6</span>f&#125;</span>&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&#x27;best_individual&#x27;</span>: best_individual,</span><br><span class="line">            <span class="string">&#x27;best_fitness&#x27;</span>: best_fitness,</span><br><span class="line">            <span class="string">&#x27;fitness_history&#x27;</span>: fitness_history</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例：优化Rastrigin函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rastrigin_function</span>(<span class="params">x: <span class="type">List</span>[<span class="built_in">float</span>]</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Rastrigin测试函数，具有多个局部极小值&quot;&quot;&quot;</span></span><br><span class="line">    A = <span class="number">10</span></span><br><span class="line">    n = <span class="built_in">len</span>(x)</span><br><span class="line">    <span class="keyword">return</span> - (A * n + <span class="built_in">sum</span>(xi2 - A * np.cos(<span class="number">2</span> * np.pi * xi) <span class="keyword">for</span> xi <span class="keyword">in</span> x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行遗传算法优化</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 设置算法参数</span></span><br><span class="line">    ga = GeneticAlgorithm(</span><br><span class="line">        population_size=<span class="number">50</span>,</span><br><span class="line">        mutation_rate=<span class="number">0.1</span>,</span><br><span class="line">        crossover_rate=<span class="number">0.8</span>,</span><br><span class="line">        generations=<span class="number">200</span></span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 定义搜索空间（2维问题）</span></span><br><span class="line">    bounds = [(-<span class="number">5.12</span>, <span class="number">5.12</span>), (-<span class="number">5.12</span>, <span class="number">5.12</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 运行优化</span></span><br><span class="line">    result = ga.run(rastrigin_function, bounds)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n遗传算法优化结果：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;最优解: <span class="subst">&#123;result[<span class="string">&#x27;best_individual&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;最优值: <span class="subst">&#123;-result[<span class="string">&#x27;best_fitness&#x27;</span>]:<span class="number">.6</span>f&#125;</span>&quot;</span>)  <span class="comment"># 注意我们求的是负函数值的最小化</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-4-实际应用案例"><a href="#3-3-4-实际应用案例" class="headerlink" title="3.3.4 实际应用案例"></a>3.3.4 实际应用案例</h3><h4 id="3-3-4-1-案例背景："><a href="#3-3-4-1-案例背景：" class="headerlink" title="3.3.4.1 案例背景："></a>3.3.4.1 案例背景：</h4><p>某物流公司需要优化其配送中心的货物摆放策略。仓库有多个货架，不同种类的货物需要摆放在不同位置。目标是最小化拣货员的平均行走距离，同时满足各种约束条件：重物放在底层、易碎品单独存放、相关货物就近摆放等。</p>
<h4 id="3-3-4-2-问题建模："><a href="#3-3-4-2-问题建模：" class="headerlink" title="3.3.4.2 问题建模："></a>3.3.4.2 问题建模：</h4><p>将货物摆放问题建模为组合优化问题。每个货物分配一个位置，目标函数为估计的总拣货距离，约束条件通过罚函数处理。</p>
<h4 id="3-3-4-3-算法实施："><a href="#3-3-4-3-算法实施：" class="headerlink" title="3.3.4.3 算法实施："></a>3.3.4.3 算法实施：</h4><ol>
<li>编码设计：使用排列编码，每个基因代表一个货物，基因值代表分配的位置</li>
<li>适应度函数：综合考虑拣货距离和约束违反程度</li>
<li>遗传操作：采用部分映射交叉保证生成可行解，交换变异引入多样性</li>
</ol>
<h4 id="3-3-4-4-优化结果："><a href="#3-3-4-4-优化结果：" class="headerlink" title="3.3.4.4 优化结果："></a>3.3.4.4 优化结果：</h4><p>经过500代进化，遗传算法找到的货物摆放方案比人工经验方案减少拣货距离25%，同时满足所有业务约束。算法运行时间约2小时，但带来的效率提升每年可节省运营成本约15万元。</p>
<h2 id="3-4-动态规划：多阶段决策的精确方法"><a href="#3-4-动态规划：多阶段决策的精确方法" class="headerlink" title="3.4 动态规划：多阶段决策的精确方法"></a>3.4 动态规划：多阶段决策的精确方法</h2><h3 id="3-4-1-算法原理阐述"><a href="#3-4-1-算法原理阐述" class="headerlink" title="3.4.1 算法原理阐述"></a>3.4.1 算法原理阐述</h3><p>动态规划是解决多阶段决策问题的经典方法，其核心思想是将复杂问题分解为相互关联的子问题，通过求解子问题并记录解，避免重复计算，最终获得全局最优解。</p>
<h4 id="3-4-1-1-最优性原理："><a href="#3-4-1-1-最优性原理：" class="headerlink" title="3.4.1.1 最优性原理："></a>3.4.1.1 最优性原理：</h4><p>动态规划的基础是贝尔曼最优性原理，即”一个最优策略具有这样的性质：无论初始状态和初始决策如何，剩余的决策必须构成关于第一个决策所产生的状态的最优策略。”这意味着问题的最优解可以通过子问题的最优解构造得到。</p>
<h4 id="3-4-1-2-方法特点："><a href="#3-4-1-2-方法特点：" class="headerlink" title="3.4.1.2 方法特点："></a>3.4.1.2 方法特点：</h4><p>动态规划特别适合处理具有重叠子问题和最优子结构性质的问题。通过记忆化存储子问题的解，算法可以将指数级的时间复杂度降低为多项式级别，是处理组合优化问题的有力工具。</p>
<h3 id="3-4-2-数学模型构建"><a href="#3-4-2-数学模型构建" class="headerlink" title="3.4.2 数学模型构建"></a>3.4.2 数学模型构建</h3><p>动态规划的基本数学模型基于贝尔曼方程：</p>
<p>对于离散确定性系统：<br>$$<br>V(i) &#x3D; \min_{a \in A(i)} \left{ c(i,a) + V(f(i,a)) \right}<br>$$</p>
<p>对于随机系统：<br>$$<br>V(i) &#x3D; \min_{a \in A(i)} \left{ c(i,a) + \sum_{j} P(j|i,a) V(j) \right}<br>$$</p>
<p>其中：</p>
<ul>
<li>$V(i)$：从状态$i$出发到目标状态的最小期望成本</li>
<li>$A(i)$：在状态$i$可用的决策集合</li>
<li>$c(i,a)$：在状态$i$采取决策$a$的即时成本</li>
<li>$f(i,a)$：状态转移函数</li>
<li>$P(j|i,a)$：状态转移概率</li>
</ul>
<h3 id="3-4-3-算法实现代码"><a href="#3-4-3-算法实现代码" class="headerlink" title="3.4.3 算法实现代码"></a>3.4.3 算法实现代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack_dp</span>(<span class="params">weights: <span class="type">List</span>[<span class="built_in">int</span>], values: <span class="type">List</span>[<span class="built_in">int</span>], capacity: <span class="built_in">int</span></span>) -&gt; <span class="type">Tuple</span>[<span class="built_in">int</span>, <span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    0-1背包问题动态规划求解</span></span><br><span class="line"><span class="string">    参数:</span></span><br><span class="line"><span class="string">        weights: 物品重量列表</span></span><br><span class="line"><span class="string">        values: 物品价值列表</span></span><br><span class="line"><span class="string">        capacity: 背包容量</span></span><br><span class="line"><span class="string">    返回:</span></span><br><span class="line"><span class="string">        最大总价值和选择的物品索引列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(weights)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建DP表，dp[i][w]表示前i个物品在容量w下的最大价值</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (capacity + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 填充DP表</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, capacity + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> weights[i-<span class="number">1</span>] &lt;= w:</span><br><span class="line">                <span class="comment"># 可以选择放入或不放入当前物品</span></span><br><span class="line">                dp[i][w] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][w], </span><br><span class="line">                              values[i-<span class="number">1</span>] + dp[i-<span class="number">1</span>][w - weights[i-<span class="number">1</span>]])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 无法放入当前物品</span></span><br><span class="line">                dp[i][w] = dp[i-<span class="number">1</span>][w]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 回溯找出选择的物品</span></span><br><span class="line">    selected_items = []</span><br><span class="line">    w = capacity</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> dp[i][w] != dp[i-<span class="number">1</span>][w]:</span><br><span class="line">            selected_items.append(i-<span class="number">1</span>)</span><br><span class="line">            w -= weights[i-<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 反转列表使物品按原始顺序排列</span></span><br><span class="line">    selected_items.reverse()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n][capacity], selected_items</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">investment_planning_dp</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    投资规划问题动态规划求解</span></span><br><span class="line"><span class="string">    问题描述：</span></span><br><span class="line"><span class="string">      有100万元资金，可以投资到3个项目</span></span><br><span class="line"><span class="string">      每个项目有不同的投资额和收益</span></span><br><span class="line"><span class="string">      目标：最大化总收益</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 投资选项：每个元组表示(投资额, 收益)</span></span><br><span class="line">    investments = [</span><br><span class="line">        (<span class="number">0</span>, <span class="number">0</span>),      <span class="comment"># 不投资</span></span><br><span class="line">        (<span class="number">20</span>, <span class="number">15</span>),    <span class="comment"># 项目1：投资20万，收益15万</span></span><br><span class="line">        (<span class="number">30</span>, <span class="number">25</span>),    <span class="comment"># 项目2：投资30万，收益25万  </span></span><br><span class="line">        (<span class="number">50</span>, <span class="number">40</span>),    <span class="comment"># 项目3：投资50万，收益40万</span></span><br><span class="line">        (<span class="number">70</span>, <span class="number">55</span>)     <span class="comment"># 项目4：投资70万，收益55万</span></span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    total_capital = <span class="number">100</span>  <span class="comment"># 总资金100万元</span></span><br><span class="line">    n = <span class="built_in">len</span>(investments)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># DP表：dp[i][j]表示考虑前i个项目，使用j万元资金的最大收益</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (total_capital + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 记录决策路径</span></span><br><span class="line">    decision = [[<span class="number">0</span>] * (total_capital + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 动态规划求解</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n):</span><br><span class="line">        investment, profit = investments[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(total_capital + <span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 不投资当前项目</span></span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j]</span><br><span class="line">            decision[i][j] = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果资金足够，考虑投资当前项目</span></span><br><span class="line">            <span class="keyword">if</span> j &gt;= investment:</span><br><span class="line">                <span class="keyword">if</span> dp[i-<span class="number">1</span>][j - investment] + profit &gt; dp[i][j]:</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j - investment] + profit</span><br><span class="line">                    decision[i][j] = i</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 回溯找出最优投资方案</span></span><br><span class="line">    current_capital = total_capital</span><br><span class="line">    investment_plan = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> decision[i][current_capital] != <span class="number">0</span>:</span><br><span class="line">            investment_plan.append(decision[i][current_capital])</span><br><span class="line">            current_capital -= investments[decision[i][current_capital]][<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    investment_plan.reverse()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n-<span class="number">1</span>][total_capital], investment_plan</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行示例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;动态规划算法示例&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span> * <span class="number">50</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 0-1背包问题示例</span></span><br><span class="line">    weights = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">    values = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">10</span>]</span><br><span class="line">    capacity = <span class="number">20</span></span><br><span class="line">    </span><br><span class="line">    max_value, selected = knapsack_dp(weights, values, capacity)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;0-1背包问题求解结果：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;物品重量: <span class="subst">&#123;weights&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;物品价值: <span class="subst">&#123;values&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;背包容量: <span class="subst">&#123;capacity&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;最大价值: <span class="subst">&#123;max_value&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;选择的物品索引: <span class="subst">&#123;selected&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;选择物品的重量: <span class="subst">&#123;[weights[i] <span class="keyword">for</span> i <span class="keyword">in</span> selected]&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;总重量: <span class="subst">&#123;<span class="built_in">sum</span>(weights[i] <span class="keyword">for</span> i <span class="keyword">in</span> selected)&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span> + <span class="string">&quot;=&quot;</span> * <span class="number">50</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 投资规划问题示例</span></span><br><span class="line">    max_profit, plan = investment_planning_dp()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;投资规划问题求解结果：&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;可用资金: 100万元&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;最大收益: <span class="subst">&#123;max_profit&#125;</span>万元&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;投资方案: <span class="subst">&#123;plan&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算总投资额</span></span><br><span class="line">    investments = [(<span class="number">0</span>,<span class="number">0</span>), (<span class="number">20</span>,<span class="number">15</span>), (<span class="number">30</span>,<span class="number">25</span>), (<span class="number">50</span>,<span class="number">40</span>), (<span class="number">70</span>,<span class="number">55</span>)]</span><br><span class="line">    total_investment = <span class="built_in">sum</span>(investments[i][<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> plan)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;总投资额: <span class="subst">&#123;total_investment&#125;</span>万元&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;资金利用率: <span class="subst">&#123;total_investment&#125;</span>/100 = <span class="subst">&#123;total_investment&#125;</span>%&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-4-4-实际应用案例"><a href="#3-4-4-实际应用案例" class="headerlink" title="3.4.4 实际应用案例"></a>3.4.4 实际应用案例</h3><h4 id="3-4-4-1-案例背景："><a href="#3-4-4-1-案例背景：" class="headerlink" title="3.4.4.1 案例背景："></a>3.4.4.1 案例背景：</h4><p>某项目经理想制定一个为期6个月的项目开发计划，项目被分解为多个相互依赖的任务。每个任务有预计完成时间、所需资源和前后依赖关系。目标是在满足任务依赖关系的前提下，合理安排任务进度，使得项目总工期最短。</p>
<h4 id="3-4-4-2-问题分析："><a href="#3-4-4-2-问题分析：" class="headerlink" title="3.4.4.2 问题分析："></a>3.4.4.2 问题分析：</h4><p>这是一个典型的关键路径问题，可以建模为有向无环图(DAG)的最长路径问题，使用动态规划求解。</p>
<h4 id="3-4-4-3-动态规划建模："><a href="#3-4-4-3-动态规划建模：" class="headerlink" title="3.4.4.3 动态规划建模："></a>3.4.4.3 动态规划建模：</h4><ol>
<li>状态定义：$dp[i]$表示到达任务$i$的最早完成时间</li>
<li>状态转移：$dp[i] &#x3D; \max_{j \in \text{pred}(i)} { dp[j] + duration(j) }$</li>
<li>初始状态：虚拟开始节点的完成时间为0</li>
<li>目标函数：所有最终任务完成时间的最大值</li>
</ol>
<h4 id="3-4-4-4-求解过程："><a href="#3-4-4-4-求解过程：" class="headerlink" title="3.4.4.4 求解过程："></a>3.4.4.4 求解过程：</h4><p>按照任务的拓扑顺序依次计算每个任务的最早开始时间，最终得到项目的关键路径和最短总工期。</p>
<h4 id="3-4-4-5-应用效果："><a href="#3-4-4-5-应用效果：" class="headerlink" title="3.4.4.5 应用效果："></a>3.4.4.5 应用效果：</h4><p>通过动态规划分析，项目经理识别出了项目的关键路径，将注意力集中在关键任务上，最终项目比原计划提前2周完成，节省了15%的人力成本。</p>
<h2 id="3-5-算法对比与选择指南"><a href="#3-5-算法对比与选择指南" class="headerlink" title="3.5 算法对比与选择指南"></a>3.5 算法对比与选择指南</h2><h3 id="3-5-1-方法特性比较"><a href="#3-5-1-方法特性比较" class="headerlink" title="3.5.1 方法特性比较"></a>3.5.1 方法特性比较</h3><div class="mdui-table-fluid mdui-shadow-0"><table class="mdui-table mdui-table-hoverable">
<thead>
<tr>
<th>特性维度</th>
<th>线性规划</th>
<th>遗传算法</th>
<th>动态规划</th>
</tr>
</thead>
<tbody><tr>
<td>求解精度</td>
<td>精确全局最优</td>
<td>近似解，质量依赖参数</td>
<td>精确全局最优</td>
</tr>
<tr>
<td>问题类型</td>
<td>线性、凸优化</td>
<td>任意类型，特别是非线性</td>
<td>多阶段决策、组合优化</td>
</tr>
<tr>
<td>计算效率</td>
<td>高，多项式时间</td>
<td>中等，依赖迭代次数</td>
<td>中等，可能状态爆炸</td>
</tr>
<tr>
<td>实现难度</td>
<td>低，有成熟工具</td>
<td>中等，需要调参</td>
<td>高，需要问题分解</td>
</tr>
<tr>
<td>适用规模</td>
<td>大规模(千级变量)</td>
<td>中小规模(百级变量)</td>
<td>小规模(状态数可控)</td>
</tr>
<tr>
<td>约束处理</td>
<td>天然支持</td>
<td>需要特殊处理</td>
<td>在状态中体现</td>
</tr>
</tbody></table></div>
<h3 id="3-5-2-实际选择建议"><a href="#3-5-2-实际选择建议" class="headerlink" title="3.5.2 实际选择建议"></a>3.5.2 实际选择建议</h3><h4 id="3-5-2-1-选择线性规划的情况："><a href="#3-5-2-1-选择线性规划的情况：" class="headerlink" title="3.5.2.1 选择线性规划的情况："></a>3.5.2.1 选择线性规划的情况：</h4><ul>
<li>问题可以表示为线性模型</li>
<li>需要保证找到全局最优解</li>
<li>问题规模较大，需要高效求解</li>
<li>有成熟的线性规划求解器可用</li>
</ul>
<h4 id="3-5-2-2-选择遗传算法的情况："><a href="#3-5-2-2-选择遗传算法的情况：" class="headerlink" title="3.5.2.2 选择遗传算法的情况："></a>3.5.2.2 选择遗传算法的情况：</h4><ul>
<li>问题高度非线性或不可微</li>
<li>搜索空间复杂，多局部最优</li>
<li>对解的质量要求不是极端严格</li>
<li>有足够的计算时间进行迭代优化</li>
</ul>
<h4 id="3-5-2-3-选择动态规划的情况："><a href="#3-5-2-3-选择动态规划的情况：" class="headerlink" title="3.5.2.3 选择动态规划的情况："></a>3.5.2.3 选择动态规划的情况：</h4><ul>
<li>问题具有明显的阶段结构</li>
<li>满足最优子结构性质</li>
<li>状态空间规模可控</li>
<li>需要精确的最优解</li>
</ul>
<h3 id="3-5-3-综合应用策略"><a href="#3-5-3-综合应用策略" class="headerlink" title="3.5.3 综合应用策略"></a>3.5.3 综合应用策略</h3><p>在实际中，往往需要组合使用多种优化方法：</p>
<ol>
<li>分层优化：先用遗传算法进行粗搜索，再用局部搜索方法精细化</li>
<li>松弛逼近：用线性规划松弛获得上界，指导其他算法的搜索</li>
<li>分解协调：将大问题分解为子问题，分别用合适的方法求解</li>
</ol>
<p>通过理解每种方法的特性和适用场景，建模者可以针对具体问题选择最合适的优化策略，或者在复杂问题中设计巧妙的算法组合，从而有效解决实际应用中的优化挑战。</p>
<h1 id="4-数据分类"><a href="#4-数据分类" class="headerlink" title="4 数据分类"></a>4 数据分类</h1><p>用于从数据中发现模式、结构和内在规律。</p>
<h2 id="4-1-聚类分析基本理论"><a href="#4-1-聚类分析基本理论" class="headerlink" title="4.1 聚类分析基本理论"></a>4.1 聚类分析基本理论</h2><h3 id="4-1-1-问题定义与数学基础"><a href="#4-1-1-问题定义与数学基础" class="headerlink" title="4.1.1 问题定义与数学基础"></a>4.1.1 问题定义与数学基础</h3><p>给定数据集 $X &#x3D; {\mathbf{x}_1, \mathbf{x}_2, \ldots, \mathbf{x}_n}$，其中每个样本 $\mathbf{x}_i \in \mathbb{R}^d$ 是一个 d 维特征向量。聚类目标是将数据集划分为 k 个互不相交的子集（簇）$C_1, C_2, \ldots, C_k$，满足：</p>
<p>$$<br>\begin{aligned}<br>&amp; \bigcup_{i&#x3D;1}^k C_i &#x3D; X \<br>&amp; C_i \cap C_j &#x3D; \emptyset, \quad \forall i \neq j \<br>&amp; C_i \neq \emptyset, \quad i &#x3D; 1, \ldots, k<br>\end{aligned}<br>$$</p>
<h3 id="4-1-2-距离度量理论"><a href="#4-1-2-距离度量理论" class="headerlink" title="4.1.2 距离度量理论"></a>4.1.2 距离度量理论</h3><h4 id="4-1-2-1-闵可夫斯基距离族："><a href="#4-1-2-1-闵可夫斯基距离族：" class="headerlink" title="4.1.2.1 闵可夫斯基距离族："></a>4.1.2.1 闵可夫斯基距离族：</h4><p>$$d_p(\mathbf{x}, \mathbf{y}) &#x3D; \left( \sum_{i&#x3D;1}^{d} |x_i - y_i|^p \right)^{1&#x2F;p}$$</p>
<ul>
<li>$p&#x3D;1$：曼哈顿距离 $d_1(\mathbf{x}, \mathbf{y}) &#x3D; \sum_{i&#x3D;1}^{d} |x_i - y_i|$</li>
<li>$p&#x3D;2$：欧氏距离 $d_2(\mathbf{x}, \mathbf{y}) &#x3D; \sqrt{\sum_{i&#x3D;1}^{d} (x_i - y_i)^2}$（最常用）</li>
<li>$p\to\infty$：切比雪夫距离 $d_\infty(\mathbf{x}, \mathbf{y}) &#x3D; \max_i |x_i - y_i|$</li>
</ul>
<h4 id="4-1-2-2-马氏距离（考虑特征相关性）："><a href="#4-1-2-2-马氏距离（考虑特征相关性）：" class="headerlink" title="4.1.2.2 马氏距离（考虑特征相关性）："></a>4.1.2.2 马氏距离（考虑特征相关性）：</h4><p>$$d_M(\mathbf{x}, \mathbf{y}) &#x3D; \sqrt{(\mathbf{x} - \mathbf{y})^T \Sigma^{-1} (\mathbf{x} - \mathbf{y})}$$<br>其中 $\Sigma$ 是协方差矩阵。</p>
<h3 id="4-1-3-数据标准化必要性"><a href="#4-1-3-数据标准化必要性" class="headerlink" title="4.1.3 数据标准化必要性"></a>4.1.3 数据标准化必要性</h3><p>为避免量纲差异影响聚类结果，必须进行数据标准化：</p>
<h4 id="4-1-3-1-Z-score-标准化："><a href="#4-1-3-1-Z-score-标准化：" class="headerlink" title="4.1.3.1 Z-score 标准化："></a>4.1.3.1 Z-score 标准化：</h4><p>$$x’ &#x3D; \frac{x - \mu}{\sigma}$$</p>
<h4 id="4-1-3-2-Robust-标准化（对异常值鲁棒）："><a href="#4-1-3-2-Robust-标准化（对异常值鲁棒）：" class="headerlink" title="4.1.3.2 Robust 标准化（对异常值鲁棒）："></a>4.1.3.2 Robust 标准化（对异常值鲁棒）：</h4><p>$$x’ &#x3D; \frac{x - \text{median}(X)}{\text{IQR}(X)}$$</p>
<h2 id="4-2-K-Means-聚类算法详解"><a href="#4-2-K-Means-聚类算法详解" class="headerlink" title="4.2 K-Means 聚类算法详解"></a>4.2 K-Means 聚类算法详解</h2><h3 id="4-2-1-算法目标函数"><a href="#4-2-1-算法目标函数" class="headerlink" title="4.2.1 算法目标函数"></a>4.2.1 算法目标函数</h3><p>K-Means 旨在最小化簇内误差平方和（Within-Cluster Sum of Squares, WCSS）：</p>
<p>$$J &#x3D; \sum_{j&#x3D;1}^{k} \sum_{\mathbf{x} \in C_j} |\mathbf{x} - \mathbf{\mu}_j|^2$$</p>
<p>其中：</p>
<ul>
<li>$C_j$ 是第 j 个簇</li>
<li>$\mathbf{\mu}<em>j &#x3D; \frac{1}{|C_j|} \sum</em>{\mathbf{x} \in C_j} \mathbf{x}$ 是簇 $C_j$ 的质心</li>
<li>$|\mathbf{x} - \mathbf{\mu}_j|$ 是样本到簇中心的欧氏距离</li>
</ul>
<h3 id="4-2-2-算法详细步骤"><a href="#4-2-2-算法详细步骤" class="headerlink" title="4.2.2 算法详细步骤"></a>4.2.2 算法详细步骤</h3><h4 id="4-2-2-1-步骤-1：初始化"><a href="#4-2-2-1-步骤-1：初始化" class="headerlink" title="4.2.2.1 步骤 1：初始化"></a>4.2.2.1 步骤 1：初始化</h4><p>随机选择 k 个样本作为初始簇中心：$\mathbf{\mu}_1^{(0)}, \mathbf{\mu}_2^{(0)}, \ldots, \mathbf{\mu}_k^{(0)}$</p>
<h4 id="4-2-2-2-步骤-2：样本分配"><a href="#4-2-2-2-步骤-2：样本分配" class="headerlink" title="4.2.2.2 步骤 2：样本分配"></a>4.2.2.2 步骤 2：样本分配</h4><p>对于每个样本 $\mathbf{x}_i$，计算到所有簇中心的距离，并将其分配到最近的簇：</p>
<p>$$C_j^{(t)} &#x3D; \left{ \mathbf{x}_i : |\mathbf{x}_i - \mathbf{\mu}_j^{(t)}| \leq |\mathbf{x}_i - \mathbf{\mu}_l^{(t)}|, \forall l \neq j \right}$$</p>
<h4 id="4-2-2-3-步骤-3：簇中心更新"><a href="#4-2-2-3-步骤-3：簇中心更新" class="headerlink" title="4.2.2.3 步骤 3：簇中心更新"></a>4.2.2.3 步骤 3：簇中心更新</h4><p>重新计算每个簇的质心：</p>
<p>$$\mathbf{\mu}<em>j^{(t+1)} &#x3D; \frac{1}{|C_j^{(t)}|} \sum</em>{\mathbf{x} \in C_j^{(t)}} \mathbf{x}$$</p>
<h4 id="4-2-2-4-步骤-4：收敛判断"><a href="#4-2-2-4-步骤-4：收敛判断" class="headerlink" title="4.2.2.4 步骤 4：收敛判断"></a>4.2.2.4 步骤 4：收敛判断</h4><p>如果 $|\mathbf{\mu}_j^{(t+1)} - \mathbf{\mu}_j^{(t)}| &lt; \varepsilon$ 对于所有 j，或者达到最大迭代次数，则算法停止；否则返回步骤 2。</p>
<h3 id="4-2-3-收敛性证明"><a href="#4-2-3-收敛性证明" class="headerlink" title="4.2.3 收敛性证明"></a>4.2.3 收敛性证明</h3><h4 id="4-2-3-1-定理：K-Means-算法在有限步内收敛到局部最优解。"><a href="#4-2-3-1-定理：K-Means-算法在有限步内收敛到局部最优解。" class="headerlink" title="4.2.3.1 定理：K-Means 算法在有限步内收敛到局部最优解。"></a>4.2.3.1 定理：K-Means 算法在有限步内收敛到局部最优解。</h4><h4 id="4-2-3-2-证明："><a href="#4-2-3-2-证明：" class="headerlink" title="4.2.3.2 证明："></a>4.2.3.2 证明：</h4><p>设第 t 次迭代的目标函数值为 $J^{(t)}$。</p>
<ol>
<li><p>在分配步骤中，固定簇中心 $\mathbf{\mu}_j^{(t)}$，将每个样本分配到最近的簇中心，这保证：<br>$$J^{(t+1&#x2F;2)} \leq J^{(t)}$$</p>
</li>
<li><p>在更新步骤中，固定簇分配 $C_j^{(t+1)}$，重新计算簇中心。由于均值最小化平方误差：<br>$$\mathbf{\mu}<em>j^{(t+1)} &#x3D; \arg\min</em>{\mathbf{\mu}} \sum_{\mathbf{x} \in C_j^{(t+1)}} |\mathbf{x} - \mathbf{\mu}|^2$$<br>因此：<br>$$J^{(t+1)} \leq J^{(t+1&#x2F;2)}$$</p>
</li>
<li><p>综合以上，有 $J^{(t+1)} \leq J^{(t)}$。由于 $J \geq 0$，序列 ${J^{(t)}}$ 单调递减且有下界，故必然收敛。</p>
</li>
</ol>
<h3 id="4-2-4-最优簇数确定：肘部法则"><a href="#4-2-4-最优簇数确定：肘部法则" class="headerlink" title="4.2.4 最优簇数确定：肘部法则"></a>4.2.4 最优簇数确定：肘部法则</h3><p>定义簇内误差平方和函数：<br>$$\text{SSE}(k) &#x3D; \sum_{j&#x3D;1}^k \sum_{\mathbf{x} \in C_j} |\mathbf{x} - \mathbf{\mu}_j|^2$$</p>
<h4 id="4-2-4-1-肘部法则原理："><a href="#4-2-4-1-肘部法则原理：" class="headerlink" title="4.2.4.1 肘部法则原理："></a>4.2.4.1 肘部法则原理：</h4><p>随着 k 增大，SSE 会单调递减。当 k 小于真实簇数时，SSE 下降幅度较大；当 k 达到真实簇数后，SSE 下降幅度显著变缓。这个转折点称为”肘部”。</p>
<h4 id="4-2-4-2-数学判断准则："><a href="#4-2-4-2-数学判断准则：" class="headerlink" title="4.2.4.2 数学判断准则："></a>4.2.4.2 数学判断准则：</h4><p>$$k^* &#x3D; \arg\min_k \left{ \frac{\text{SSE}(k) - \text{SSE}(k+1)}{\text{SSE}(k+1) - \text{SSE}(k+2)} \right}$$</p>
<h3 id="4-2-5-K-Means-实现代码"><a href="#4-2-5-K-Means-实现代码" class="headerlink" title="4.2.5 K-Means 实现代码"></a>4.2.5 K-Means 实现代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">kmeans_analysis</span>(<span class="params">X, max_k=<span class="number">10</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    K-Means聚类完整分析</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 数据标准化</span></span><br><span class="line">    scaler = StandardScaler()</span><br><span class="line">    X_scaled = scaler.fit_transform(X)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 肘部法则确定最优k值</span></span><br><span class="line">    sse = []</span><br><span class="line">    k_range = <span class="built_in">range</span>(<span class="number">1</span>, max_k + <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> k_range:</span><br><span class="line">        kmeans = KMeans(n_clusters=k, random_state=<span class="number">42</span>, n_init=<span class="number">10</span>)</span><br><span class="line">        kmeans.fit(X_scaled)</span><br><span class="line">        sse.append(kmeans.inertia_)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 绘制肘部图</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">    plt.plot(k_range, sse, <span class="string">&#x27;bo-&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Number of Clusters (k)&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Sum of Squared Errors (SSE)&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Elbow Method for Optimal k&#x27;</span>)</span><br><span class="line">    plt.grid(<span class="literal">True</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算SSE下降率确定肘点</span></span><br><span class="line">    sse_reduction = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(sse) - <span class="number">1</span>):</span><br><span class="line">        reduction = (sse[i-<span class="number">1</span>] - sse[i]) / (sse[i] - sse[i+<span class="number">1</span>])</span><br><span class="line">        sse_reduction.append(reduction)</span><br><span class="line">    </span><br><span class="line">    optimal_k = np.argmax(sse_reduction) + <span class="number">2</span>  <span class="comment"># +2因为从k=2开始计算</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;根据肘部法则，推荐簇数: <span class="subst">&#123;optimal_k&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用最优k值进行聚类</span></span><br><span class="line">    kmeans_optimal = KMeans(n_clusters=optimal_k, random_state=<span class="number">42</span>)</span><br><span class="line">    labels = kmeans_optimal.fit_predict(X_scaled)</span><br><span class="line">    centers = kmeans_optimal.cluster_centers_</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> labels, centers, kmeans_optimal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="comment"># 假设 X 是 n×d 的数据矩阵</span></span><br><span class="line"><span class="comment"># labels, centers, model = kmeans_analysis(X)</span></span><br></pre></td></tr></table></figure>

<h2 id="4-3-层次聚类算法"><a href="#4-3-层次聚类算法" class="headerlink" title="4.3 层次聚类算法"></a>4.3 层次聚类算法</h2><h3 id="4-3-1-算法基本原理"><a href="#4-3-1-算法基本原理" class="headerlink" title="4.3.1 算法基本原理"></a>4.3.1 算法基本原理</h3><p>层次聚类通过构建树状结构（dendrogram）来展示数据的层次分组关系，主要有两种策略：</p>
<h4 id="4-3-1-1-凝聚层次聚类（自底向上）："><a href="#4-3-1-1-凝聚层次聚类（自底向上）：" class="headerlink" title="4.3.1.1 凝聚层次聚类（自底向上）："></a>4.3.1.1 凝聚层次聚类（自底向上）：</h4><ol>
<li>开始时每个样本自成一类</li>
<li>迭代地合并最相似的两个类</li>
<li>直到所有样本合并为一类</li>
</ol>
<h4 id="4-3-1-2-分裂层次聚类（自顶向下）："><a href="#4-3-1-2-分裂层次聚类（自顶向下）：" class="headerlink" title="4.3.1.2 分裂层次聚类（自顶向下）："></a>4.3.1.2 分裂层次聚类（自顶向下）：</h4><ol>
<li>开始时所有样本属于同一类</li>
<li>迭代地分裂差异最大的类</li>
<li>直到每个样本自成一类</li>
</ol>
<h3 id="4-3-2-链接方法数学定义"><a href="#4-3-2-链接方法数学定义" class="headerlink" title="4.3.2 链接方法数学定义"></a>4.3.2 链接方法数学定义</h3><h4 id="4-3-2-1-单链接（最近邻）："><a href="#4-3-2-1-单链接（最近邻）：" class="headerlink" title="4.3.2.1 单链接（最近邻）："></a>4.3.2.1 单链接（最近邻）：</h4><p>$$d_{\text{single}}(C_i, C_j) &#x3D; \min_{\mathbf{x} \in C_i, \mathbf{y} \in C_j} d(\mathbf{x}, \mathbf{y})$$</p>
<h4 id="4-3-2-2-全链接（最远邻）："><a href="#4-3-2-2-全链接（最远邻）：" class="headerlink" title="4.3.2.2 全链接（最远邻）："></a>4.3.2.2 全链接（最远邻）：</h4><p>$$d_{\text{complete}}(C_i, C_j) &#x3D; \max_{\mathbf{x} \in C_i, \mathbf{y} \in C_j} d(\mathbf{x}, \mathbf{y})$$</p>
<h4 id="4-3-2-3-平均链接："><a href="#4-3-2-3-平均链接：" class="headerlink" title="4.3.2.3 平均链接："></a>4.3.2.3 平均链接：</h4><p>$$d_{\text{average}}(C_i, C_j) &#x3D; \frac{1}{|C_i||C_j|} \sum_{\mathbf{x} \in C_i} \sum_{\mathbf{y} \in C_j} d(\mathbf{x}, \mathbf{y})$$</p>
<h4 id="4-3-2-4-Ward方法（方差最小化）："><a href="#4-3-2-4-Ward方法（方差最小化）：" class="headerlink" title="4.3.2.4 Ward方法（方差最小化）："></a>4.3.2.4 Ward方法（方差最小化）：</h4><p>$$d_{\text{Ward}}(C_i, C_j) &#x3D; \frac{|C_i||C_j|}{|C_i| + |C_j|} |\mathbf{\mu}_i - \mathbf{\mu}_j|^2$$</p>
<h4 id="4-3-2-5-定理：Ward-方法等价于最小化合并后总方差的增加。"><a href="#4-3-2-5-定理：Ward-方法等价于最小化合并后总方差的增加。" class="headerlink" title="4.3.2.5 定理：Ward 方法等价于最小化合并后总方差的增加。"></a>4.3.2.5 定理：Ward 方法等价于最小化合并后总方差的增加。</h4><h4 id="4-3-2-6-证明："><a href="#4-3-2-6-证明：" class="headerlink" title="4.3.2.6 证明："></a>4.3.2.6 证明：</h4><p>合并前的总方差：<br>$$V_{\text{before}} &#x3D; \sum_{\mathbf{x} \in C_i} |\mathbf{x} - \mathbf{\mu}<em>i|^2 + \sum</em>{\mathbf{x} \in C_j} |\mathbf{x} - \mathbf{\mu}_j|^2$$</p>
<p>合并后的方差：<br>$$V_{\text{after}} &#x3D; \sum_{\mathbf{x} \in C_i \cup C_j} |\mathbf{x} - \mathbf{\mu}_{ij}|^2$$</p>
<p>其中 $\mathbf{\mu}_{ij} &#x3D; \frac{|C_i|\mathbf{\mu}_i + |C_j|\mathbf{\mu}_j}{|C_i| + |C_j|}$。</p>
<p>方差增加量：<br>$$\Delta V &#x3D; V_{\text{after}} - V_{\text{before}} &#x3D; \frac{|C_i||C_j|}{|C_i| + |C_j|} |\mathbf{\mu}_i - \mathbf{\mu}_j|^2$$</p>
<h3 id="4-3-3-层次聚类实现"><a href="#4-3-3-层次聚类实现" class="headerlink" title="4.3.3 层次聚类实现"></a>4.3.3 层次聚类实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> AgglomerativeClustering</span><br><span class="line"><span class="keyword">import</span> scipy.cluster.hierarchy <span class="keyword">as</span> sch</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hierarchical_clustering_analysis</span>(<span class="params">X, method=<span class="string">&#x27;ward&#x27;</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    层次聚类完整分析</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 数据标准化</span></span><br><span class="line">    scaler = StandardScaler()</span><br><span class="line">    X_scaled = scaler.fit_transform(X)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 绘制树状图</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">12</span>, <span class="number">8</span>))</span><br><span class="line">    dendrogram = sch.dendrogram(</span><br><span class="line">        sch.linkage(X_scaled, method=method),</span><br><span class="line">        truncate_mode=<span class="string">&#x27;lastp&#x27;</span>,</span><br><span class="line">        p=<span class="number">30</span>,</span><br><span class="line">        show_leaf_counts=<span class="literal">True</span>,</span><br><span class="line">        leaf_rotation=<span class="number">90</span>,</span><br><span class="line">        leaf_font_size=<span class="number">10</span></span><br><span class="line">    )</span><br><span class="line">    plt.title(<span class="string">f&#x27;Hierarchical Clustering Dendrogram (<span class="subst">&#123;method&#125;</span> linkage)&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Sample Index&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Distance&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 从树状图确定最佳簇数（示例）</span></span><br><span class="line">    <span class="comment"># 在实际应用中，应根据树状图的垂直距离跳跃确定切割高度</span></span><br><span class="line">    optimal_k = <span class="number">3</span>  <span class="comment"># 这需要根据具体树状图确定</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 执行层次聚类</span></span><br><span class="line">    agg_clustering = AgglomerativeClustering(</span><br><span class="line">        n_clusters=optimal_k, </span><br><span class="line">        linkage=method</span><br><span class="line">    )</span><br><span class="line">    labels = agg_clustering.fit_predict(X_scaled)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> labels, dendrogram</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="comment"># labels, dendrogram = hierarchical_clustering_analysis(X, method=&#x27;ward&#x27;)</span></span><br></pre></td></tr></table></figure>

<h2 id="4-4-DBSCAN-密度聚类"><a href="#4-4-DBSCAN-密度聚类" class="headerlink" title="4.4 DBSCAN 密度聚类"></a>4.4 DBSCAN 密度聚类</h2><h3 id="4-4-1-核心概念数学定义"><a href="#4-4-1-核心概念数学定义" class="headerlink" title="4.4.1 核心概念数学定义"></a>4.4.1 核心概念数学定义</h3><h4 id="4-4-1-1-定义-1（-varepsilon-邻域）："><a href="#4-4-1-1-定义-1（-varepsilon-邻域）：" class="headerlink" title="4.4.1.1 定义 1（$\varepsilon$-邻域）："></a>4.4.1.1 定义 1（$\varepsilon$-邻域）：</h4><p>$$N_\varepsilon(\mathbf{x}) &#x3D; {\mathbf{y} \in X : d(\mathbf{x}, \mathbf{y}) \leq \varepsilon}$$</p>
<h4 id="4-4-1-2-定义-2（核心点）："><a href="#4-4-1-2-定义-2（核心点）：" class="headerlink" title="4.4.1.2 定义 2（核心点）："></a>4.4.1.2 定义 2（核心点）：</h4><p>点 $\mathbf{x}$ 是核心点当且仅当 $|N_\varepsilon(\mathbf{x})| \geq \text{minPts}$</p>
<h4 id="4-4-1-3-定义-3（直接密度可达）："><a href="#4-4-1-3-定义-3（直接密度可达）：" class="headerlink" title="4.4.1.3 定义 3（直接密度可达）："></a>4.4.1.3 定义 3（直接密度可达）：</h4><p>点 $\mathbf{y}$ 从 $\mathbf{x}$ 直接密度可达当且仅当：</p>
<ol>
<li>$\mathbf{x}$ 是核心点</li>
<li>$\mathbf{y} \in N_\varepsilon(\mathbf{x})$</li>
</ol>
<h4 id="4-4-1-4-定义-4（密度可达）："><a href="#4-4-1-4-定义-4（密度可达）：" class="headerlink" title="4.4.1.4 定义 4（密度可达）："></a>4.4.1.4 定义 4（密度可达）：</h4><p>点 $\mathbf{y}$ 从 $\mathbf{x}$ 密度可达当且仅当存在点序列 $\mathbf{p}_1, \ldots, \mathbf{p}_n$ 使得：</p>
<ul>
<li>$\mathbf{p}_1 &#x3D; \mathbf{x}$, $\mathbf{p}_n &#x3D; \mathbf{y}$</li>
<li>$\mathbf{p}_{i+1}$ 从 $\mathbf{p}_i$ 直接密度可达</li>
</ul>
<h4 id="4-4-1-5-定义-5（密度相连）："><a href="#4-4-1-5-定义-5（密度相连）：" class="headerlink" title="4.4.1.5 定义 5（密度相连）："></a>4.4.1.5 定义 5（密度相连）：</h4><p>点 $\mathbf{x}$ 和 $\mathbf{y}$ 密度相连当且仅当存在点 $\mathbf{z}$ 使得 $\mathbf{x}$ 和 $\mathbf{y}$ 都从 $\mathbf{z}$ 密度可达。</p>
<h3 id="4-4-2-算法理论基础"><a href="#4-4-2-算法理论基础" class="headerlink" title="4.4.2 算法理论基础"></a>4.4.2 算法理论基础</h3><h4 id="4-4-2-1-定理：DBSCAN-形成的簇-C-满足："><a href="#4-4-2-1-定理：DBSCAN-形成的簇-C-满足：" class="headerlink" title="4.4.2.1 定理：DBSCAN 形成的簇 $C$ 满足："></a>4.4.2.1 定理：DBSCAN 形成的簇 $C$ 满足：</h4><ol>
<li>$\forall \mathbf{x}, \mathbf{y} \in C$，$\mathbf{x}$ 和 $\mathbf{y}$ 密度相连</li>
<li>$\forall \mathbf{x} \in C$，如果 $\mathbf{y}$ 从 $\mathbf{x}$ 密度可达，则 $\mathbf{y} \in C$</li>
</ol>
<h3 id="4-4-3-参数选择方法"><a href="#4-4-3-参数选择方法" class="headerlink" title="4.4.3 参数选择方法"></a>4.4.3 参数选择方法</h3><h4 id="4-4-3-1-varepsilon-参数选择："><a href="#4-4-3-1-varepsilon-参数选择：" class="headerlink" title="4.4.3.1 $\varepsilon$ 参数选择："></a>4.4.3.1 $\varepsilon$ 参数选择：</h4><p>使用 k-距离图方法，对于每个点计算到第 $\text{minPts}$ 近邻的距离，排序后绘图，选择拐点处的值作为 $\varepsilon$。</p>
<h4 id="4-4-3-2-minPts-选择："><a href="#4-4-3-2-minPts-选择：" class="headerlink" title="4.4.3.2 minPts 选择："></a>4.4.3.2 minPts 选择：</h4><p>一般设置为 $2 \times \text{维度数}$。</p>
<h3 id="4-4-4-DBSCAN-实现"><a href="#4-4-4-DBSCAN-实现" class="headerlink" title="4.4.4 DBSCAN 实现"></a>4.4.4 DBSCAN 实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> DBSCAN</span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> NearestNeighbors</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbscan_analysis</span>(<span class="params">X, min_samples=<span class="literal">None</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    DBSCAN聚类完整分析</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="comment"># 数据标准化</span></span><br><span class="line">    scaler = StandardScaler()</span><br><span class="line">    X_scaled = scaler.fit_transform(X)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 自动确定min_samples</span></span><br><span class="line">    <span class="keyword">if</span> min_samples <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        min_samples = <span class="number">2</span> * X_scaled.shape[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 寻找最优eps参数</span></span><br><span class="line">    neighbors = NearestNeighbors(n_neighbors=min_samples)</span><br><span class="line">    neighbors_fit = neighbors.fit(X_scaled)</span><br><span class="line">    distances, indices = neighbors_fit.kneighbors(X_scaled)</span><br><span class="line">    </span><br><span class="line">    k_distances = np.sort(distances[:, min_samples-<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 绘制k-距离图</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">    plt.plot(k_distances)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Data Points Sorted by Distance&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">f&#x27;<span class="subst">&#123;min_samples&#125;</span>-NN Distance&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;K-Distance Graph for Optimal Eps&#x27;</span>)</span><br><span class="line">    plt.grid(<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 自动选择eps（使用第95百分位数）</span></span><br><span class="line">    optimal_eps = np.percentile(k_distances, <span class="number">95</span>)</span><br><span class="line">    plt.axhline(y=optimal_eps, color=<span class="string">&#x27;r&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, </span><br><span class="line">                label=<span class="string">f&#x27;Recommended eps: <span class="subst">&#123;optimal_eps:<span class="number">.2</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 执行DBSCAN聚类</span></span><br><span class="line">    dbscan = DBSCAN(eps=optimal_eps, min_samples=min_samples)</span><br><span class="line">    labels = dbscan.fit_predict(X_scaled)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 统计结果</span></span><br><span class="line">    n_clusters = <span class="built_in">len</span>(<span class="built_in">set</span>(labels)) - (<span class="number">1</span> <span class="keyword">if</span> -<span class="number">1</span> <span class="keyword">in</span> labels <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">    n_noise = <span class="built_in">list</span>(labels).count(-<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;DBSCAN聚类结果:&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;簇数量: <span class="subst">&#123;n_clusters&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;噪声点数量: <span class="subst">&#123;n_noise&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;噪声点比例: <span class="subst">&#123;n_noise/<span class="built_in">len</span>(X_scaled):<span class="number">.2</span>%&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> labels, dbscan</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="comment"># labels, dbscan_model = dbscan_analysis(X)</span></span><br></pre></td></tr></table></figure>

<h2 id="4-5-聚类质量评估"><a href="#4-5-聚类质量评估" class="headerlink" title="4.5 聚类质量评估"></a>4.5 聚类质量评估</h2><h3 id="4-5-1-内部评估指标"><a href="#4-5-1-内部评估指标" class="headerlink" title="4.5.1 内部评估指标"></a>4.5.1 内部评估指标</h3><h4 id="4-5-1-1-轮廓系数："><a href="#4-5-1-1-轮廓系数：" class="headerlink" title="4.5.1.1 轮廓系数："></a>4.5.1.1 轮廓系数：</h4><p>对于样本 $\mathbf{x}_i$：<br>$$s(i) &#x3D; \frac{b(i) - a(i)}{\max{a(i), b(i)}}$$</p>
<p>其中：</p>
<ul>
<li>$a(i) &#x3D; \frac{1}{|C_i| - 1} \sum_{\mathbf{x}_j \in C_i, j \neq i} d(\mathbf{x}_i, \mathbf{x}_j)$（组内平均距离）</li>
<li>$b(i) &#x3D; \min_{k \neq i} \frac{1}{|C_k|} \sum_{\mathbf{x}_j \in C_k} d(\mathbf{x}_i, \mathbf{x}_j)$（组间最小平均距离）</li>
</ul>
<p>整体轮廓系数：<br>$$S &#x3D; \frac{1}{n} \sum_{i&#x3D;1}^n s(i)$$</p>
<h4 id="4-5-1-2-解释："><a href="#4-5-1-2-解释：" class="headerlink" title="4.5.1.2 解释："></a>4.5.1.2 解释：</h4><ul>
<li>$S \approx 1$：聚类效果很好</li>
<li>$S \approx 0$：聚类效果一般</li>
<li>$S \approx -1$：聚类效果很差</li>
</ul>
<h4 id="4-5-1-3-Calinski-Harabasz-指数："><a href="#4-5-1-3-Calinski-Harabasz-指数：" class="headerlink" title="4.5.1.3 Calinski-Harabasz 指数："></a>4.5.1.3 Calinski-Harabasz 指数：</h4><p>$$\text{CH} &#x3D; \frac{\text{tr}(B)&#x2F;(k-1)}{\text{tr}(W)&#x2F;(n-k)}$$</p>
<p>其中：</p>
<ul>
<li>$\text{tr}(B) &#x3D; \sum_{j&#x3D;1}^k |C_j| |\mathbf{\mu}_j - \mathbf{\mu}|^2$（簇间离散度）</li>
<li>$\text{tr}(W) &#x3D; \sum_{j&#x3D;1}^k \sum_{\mathbf{x} \in C_j} |\mathbf{x} - \mathbf{\mu}_j|^2$（簇内离散度）</li>
<li>$\mathbf{\mu}$ 为总体均值</li>
</ul>
<p>值越大表示聚类效果越好。</p>
<h4 id="4-5-1-4-Davies-Bouldin-指数："><a href="#4-5-1-4-Davies-Bouldin-指数：" class="headerlink" title="4.5.1.4 Davies-Bouldin 指数："></a>4.5.1.4 Davies-Bouldin 指数：</h4><p>$$\text{DB} &#x3D; \frac{1}{k} \sum_{i&#x3D;1}^k \max_{j \neq i} R_{ij}$$</p>
<p>其中：<br>$$R_{ij} &#x3D; \frac{s_i + s_j}{d(\mathbf{\mu}_i, \mathbf{\mu}<em>j)}$$<br>$$s_i &#x3D; \frac{1}{|C_i|} \sum</em>{\mathbf{x} \in C_i} |\mathbf{x} - \mathbf{\mu}_i|$$</p>
<p>值越小表示聚类效果越好。</p>
<h3 id="4-5-2-评估实现代码"><a href="#4-5-2-评估实现代码" class="headerlink" title="4.5.2 评估实现代码"></a>4.5.2 评估实现代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> silhouette_score, calinski_harabasz_score, davies_bouldin_score</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate_clustering</span>(<span class="params">X, labels</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    综合评估聚类结果</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">set</span>(labels)) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;警告：簇数量少于2，无法计算评估指标&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    metrics = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 轮廓系数</span></span><br><span class="line">    metrics[<span class="string">&#x27;silhouette&#x27;</span>] = silhouette_score(X, labels)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Calinski-Harabasz指数</span></span><br><span class="line">    metrics[<span class="string">&#x27;calinski_harabasz&#x27;</span>] = calinski_harabasz_score(X, labels)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># Davies-Bouldin指数</span></span><br><span class="line">    metrics[<span class="string">&#x27;davies_bouldin&#x27;</span>] = davies_bouldin_score(X, labels)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 打印结果</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;=== 聚类质量评估 ===&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;轮廓系数: <span class="subst">&#123;metrics[<span class="string">&#x27;silhouette&#x27;</span>]:<span class="number">.4</span>f&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Calinski-Harabasz指数: <span class="subst">&#123;metrics[<span class="string">&#x27;calinski_harabasz&#x27;</span>]:<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Davies-Bouldin指数: <span class="subst">&#123;metrics[<span class="string">&#x27;davies_bouldin&#x27;</span>]:<span class="number">.4</span>f&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 轮廓系数解释</span></span><br><span class="line">    silhouette = metrics[<span class="string">&#x27;silhouette&#x27;</span>]</span><br><span class="line">    <span class="keyword">if</span> silhouette &gt; <span class="number">0.7</span>:</span><br><span class="line">        interpretation = <span class="string">&quot;强聚类结构&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> silhouette &gt; <span class="number">0.5</span>:</span><br><span class="line">        interpretation = <span class="string">&quot;合理的聚类结构&quot;</span></span><br><span class="line">    <span class="keyword">elif</span> silhouette &gt; <span class="number">0.25</span>:</span><br><span class="line">        interpretation = <span class="string">&quot;弱的聚类结构&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        interpretation = <span class="string">&quot;没有实质的聚类结构&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;轮廓系数解释: <span class="subst">&#123;interpretation&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> metrics</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="comment"># metrics = evaluate_clustering(X_scaled, labels)</span></span><br></pre></td></tr></table></figure>

<h2 id="4-6-数学建模应用框架"><a href="#4-6-数学建模应用框架" class="headerlink" title="4.6 数学建模应用框架"></a>4.6 数学建模应用框架</h2><h3 id="4-6-1-完整建模流程"><a href="#4-6-1-完整建模流程" class="headerlink" title="4.6.1 完整建模流程"></a>4.6.1 完整建模流程</h3><ol>
<li>问题理解：明确聚类分析要解决的具体问题</li>
<li>数据预处理：处理缺失值、异常值，进行标准化</li>
<li>方法选择：根据数据特征选择合适</li>
</ol>
<h1 id="5-统计与不确定性建模"><a href="#5-统计与不确定性建模" class="headerlink" title="5 统计与不确定性建模"></a>5 统计与不确定性建模</h1><p>处理随机性和不确定性，基于概率论进行推断和决策。</p>
<h2 id="5-1-蒙特卡洛模拟"><a href="#5-1-蒙特卡洛模拟" class="headerlink" title="5.1 蒙特卡洛模拟"></a>5.1 蒙特卡洛模拟</h2><h3 id="5-1-1-核心思想"><a href="#5-1-1-核心思想" class="headerlink" title="5.1.1 核心思想"></a>5.1.1 核心思想</h3><p>蒙特卡洛模拟是一种通过大量随机抽样来获得问题近似解的数值方法。其基本理念是用”暴力”但有效的方式解决复杂问题——通过生成大量随机样本来模拟一个系统，然后从这些样本结果中统计出我们关心的量（如均值、概率、分布等）。</p>
<h3 id="5-1-2-通俗理解"><a href="#5-1-2-通俗理解" class="headerlink" title="5.1.2 通俗理解"></a>5.1.2 通俗理解</h3><p>想象要计算一个不规则形状湖面的面积，但只有一张湖的卫星照片和一个无限的豆子袋。蒙上眼睛随机向整张照片扔豆子，然后数出落在湖里的豆子比例。如果知道照片的总面积，用这个比例乘以总面积就能近似得到湖的面积。扔的豆子越多，结果就越精确。这就是蒙特卡洛模拟的精髓。</p>
<h3 id="5-1-3-数学原理"><a href="#5-1-3-数学原理" class="headerlink" title="5.1.3 数学原理"></a>5.1.3 数学原理</h3><h4 id="5-1-3-1-大数定律"><a href="#5-1-3-1-大数定律" class="headerlink" title="5.1.3.1 大数定律"></a>5.1.3.1 大数定律</h4><p>设 $X_1, X_2, …, X_n$ 是独立同分布的随机变量，期望为 $E(X) &#x3D; \mu$。则样本平均值 $\bar{X}<em>n &#x3D; \frac{1}{n} \sum</em>{i&#x3D;1}^n X_i$ 随着 $n$ 增大，以概率1收敛于 $\mu$：<br>$$<br>\bar{X}_n \stackrel{\text{a.s.}}{\longrightarrow} \mu \quad \text{当 } n \to \infty<br>$$<br>这保证了模拟的长期稳定性。</p>
<h4 id="5-1-3-2-中心极限定理"><a href="#5-1-3-2-中心极限定理" class="headerlink" title="5.1.3.2 中心极限定理"></a>5.1.3.2 中心极限定理</h4><p>无论 $X$ 的原始分布是什么，样本均值 $\bar{X}<em>n$ 的分布都近似于正态分布。这允许我们为估计值构建置信区间：<br>$$<br>\sigma</em>{\bar{X}} &#x3D; \frac{\sigma}{\sqrt{n}}<br>$$<br>其中 $\sigma$ 是 $X$ 的标准差，$n$ 是样本数。</p>
<h4 id="5-1-3-3-计算圆周率-π-的示例"><a href="#5-1-3-3-计算圆周率-π-的示例" class="headerlink" title="5.1.3.3 计算圆周率 π 的示例"></a>5.1.3.3 计算圆周率 π 的示例</h4><ul>
<li>单位圆面积：π</li>
<li>外接正方形面积：4</li>
<li>点落在圆内的概率：$p &#x3D; \frac{\pi}{4}$</li>
<li>估计公式：$\pi \approx 4 \times \frac{\text{圆内点数}}{\text{总点数}}$</li>
</ul>
<h3 id="5-1-4-代码实现"><a href="#5-1-4-代码实现" class="headerlink" title="5.1.4 代码实现"></a>5.1.4 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">monte_carlo_pi</span>(<span class="params">num_samples</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用蒙特卡洛方法计算圆周率π&quot;&quot;&quot;</span></span><br><span class="line">    np.random.seed(<span class="number">42</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 在正方形区域内随机生成点</span></span><br><span class="line">    x = np.random.uniform(-<span class="number">1</span>, <span class="number">1</span>, num_samples)</span><br><span class="line">    y = np.random.uniform(-<span class="number">1</span>, <span class="number">1</span>, num_samples)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算每个点到原点的距离</span></span><br><span class="line">    distance_squared = x2 + y2</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 判断点是否在圆内</span></span><br><span class="line">    inside_circle = distance_squared &lt;= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 统计圆内的点数</span></span><br><span class="line">    points_inside = np.<span class="built_in">sum</span>(inside_circle)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算π的估计值</span></span><br><span class="line">    pi_estimate = <span class="number">4</span> * points_inside / num_samples</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pi_estimate, x, y, inside_circle</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用不同样本数量进行测试</span></span><br><span class="line">sample_sizes = [<span class="number">1000</span>, <span class="number">10000</span>, <span class="number">100000</span>, <span class="number">1000000</span>]</span><br><span class="line">results = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> sample_sizes:</span><br><span class="line">    pi_est, x, y, inside = monte_carlo_pi(n)</span><br><span class="line">    results[n] = pi_est</span><br><span class="line">    error = <span class="built_in">abs</span>(pi_est - np.pi)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;样本数: <span class="subst">&#123;n:8d&#125;</span> | π估计值: <span class="subst">&#123;pi_est:<span class="number">.6</span>f&#125;</span> | 误差: <span class="subst">&#123;error:<span class="number">.6</span>f&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化最后一种情况</span></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">plt.scatter(x[inside], y[inside], color=<span class="string">&#x27;blue&#x27;</span>, s=<span class="number">1</span>, alpha=<span class="number">0.6</span>, label=<span class="string">&#x27;圆内点&#x27;</span>)</span><br><span class="line">plt.scatter(x[~inside], y[~inside], color=<span class="string">&#x27;red&#x27;</span>, s=<span class="number">1</span>, alpha=<span class="number">0.6</span>, label=<span class="string">&#x27;圆外点&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">f&#x27;蒙特卡洛模拟计算 π (样本数: <span class="subst">&#123;n&#125;</span>, 估计值: <span class="subst">&#123;pi_est:<span class="number">.4</span>f&#125;</span>)&#x27;</span>)</span><br><span class="line">plt.axis(<span class="string">&#x27;equal&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h3 id="5-1-5-应用场景"><a href="#5-1-5-应用场景" class="headerlink" title="5.1.5 应用场景"></a>5.1.5 应用场景</h3><h4 id="5-1-5-1-金融工程"><a href="#5-1-5-1-金融工程" class="headerlink" title="5.1.5.1 金融工程"></a>5.1.5.1 金融工程</h4><ul>
<li>期权定价：模拟股票价格未来可能路径，根据最终收益计算期权平均收益并折现</li>
<li>风险价值计算：模拟市场因素随机变化，评估投资组合在给定置信水平下的最大可能损失</li>
</ul>
<h4 id="5-1-5-2-科学与工程"><a href="#5-1-5-2-科学与工程" class="headerlink" title="5.1.5.2 科学与工程"></a>5.1.5.2 科学与工程</h4><ul>
<li>复杂积分计算：高维积分计算，传统数值方法效率低，蒙特卡洛不受维度限制</li>
<li>粒子输运：模拟中子、光子在介质中的随机碰撞、散射和吸收</li>
</ul>
<h4 id="5-1-5-3-人工智能"><a href="#5-1-5-3-人工智能" class="headerlink" title="5.1.5.3 人工智能"></a>5.1.5.3 人工智能</h4><ul>
<li>蒙特卡洛树搜索：AlphaGo等围棋AI的核心算法，通过随机模拟未来棋局评估走法优劣</li>
</ul>
<h2 id="5-2-随机过程模型"><a href="#5-2-随机过程模型" class="headerlink" title="5.2 随机过程模型"></a>5.2 随机过程模型</h2><h3 id="5-2-1-核心思想"><a href="#5-2-1-核心思想" class="headerlink" title="5.2.1 核心思想"></a>5.2.1 核心思想</h3><p>随机过程模型研究一系列随机变量的集合，这些变量按照时间或空间顺序排列，用于描述动态的、随时间演化且含有随机性的系统。</p>
<h3 id="5-2-2-基本概念"><a href="#5-2-2-基本概念" class="headerlink" title="5.2.2 基本概念"></a>5.2.2 基本概念</h3><p>随机过程 ${X_t, t \in T}$ 是一个随机变量的集合，其中索引集 $T$ 通常代表时间。</p>
<h3 id="5-2-3-主要类型"><a href="#5-2-3-主要类型" class="headerlink" title="5.2.3 主要类型"></a>5.2.3 主要类型</h3><h4 id="5-2-3-1-随机游走（离散时间）"><a href="#5-2-3-1-随机游走（离散时间）" class="headerlink" title="5.2.3.1 随机游走（离散时间）"></a>5.2.3.1 随机游走（离散时间）</h4><ul>
<li>定义：$S_0 &#x3D; 0$（初始位置）</li>
<li>递推公式：$S_n &#x3D; S_{n-1} + X_n$</li>
<li>其中 $X_n$ 是独立同分布的随机步长</li>
<li>简单对称随机游走：$P(X_n &#x3D; 1) &#x3D; 0.5, P(X_n &#x3D; -1) &#x3D; 0.5$</li>
</ul>
<h4 id="5-2-3-2-几何布朗运动（连续时间）"><a href="#5-2-3-2-几何布朗运动（连续时间）" class="headerlink" title="5.2.3.2 几何布朗运动（连续时间）"></a>5.2.3.2 几何布朗运动（连续时间）</h4><p>金融中用于模拟资产价格的连续时间随机过程，满足随机微分方程：<br>$$<br>dS_t &#x3D; \mu S_t dt + \sigma S_t dW_t<br>$$</p>
<p>其中：</p>
<ul>
<li>$S_t$：时间 t 的资产价格</li>
<li>$\mu$：漂移率（平均回报率）</li>
<li>$\sigma$：波动率（价格变动的不确定性）</li>
<li>$W_t$：标准布朗运动（维纳过程）</li>
</ul>
<p>解析解：<br>$$<br>S_t &#x3D; S_0 \exp\left( \left(\mu - \frac{\sigma^2}{2}\right)t + \sigma W_t \right)<br>$$</p>
<h3 id="5-2-4-代码实现"><a href="#5-2-4-代码实现" class="headerlink" title="5.2.4 代码实现"></a>5.2.4 代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">geometric_brownian_motion</span>(<span class="params">S0, mu, sigma, T, dt, num_paths</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;模拟几何布朗运动路径&quot;&quot;&quot;</span></span><br><span class="line">    np.random.seed(<span class="number">42</span>)</span><br><span class="line">    </span><br><span class="line">    num_steps = <span class="built_in">int</span>(T / dt)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 初始化价格数组</span></span><br><span class="line">    S = np.zeros((num_steps + <span class="number">1</span>, num_paths))</span><br><span class="line">    S[<span class="number">0</span>] = S0</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 模拟路径</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, num_steps + <span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 生成标准正态分布的随机数</span></span><br><span class="line">        Z = np.random.standard_normal(num_paths)</span><br><span class="line">        <span class="comment"># 根据几何布朗运动公式更新价格</span></span><br><span class="line">        S[t] = S[t-<span class="number">1</span>] * np.exp((mu - <span class="number">0.5</span> * sigma2) * dt + sigma * np.sqrt(dt) * Z)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> S</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数设置</span></span><br><span class="line">S0 = <span class="number">100.0</span>       <span class="comment"># 初始股价</span></span><br><span class="line">mu = <span class="number">0.05</span>        <span class="comment"># 预期年化回报率 (5%)</span></span><br><span class="line">sigma = <span class="number">0.2</span>      <span class="comment"># 年化波动率 (20%)</span></span><br><span class="line">T = <span class="number">2.0</span>          <span class="comment"># 时间长度 (2年)</span></span><br><span class="line">dt = <span class="number">1</span>/<span class="number">252</span>       <span class="comment"># 时间步长 (交易日)</span></span><br><span class="line">num_paths = <span class="number">10</span>   <span class="comment"># 模拟路径数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行模拟</span></span><br><span class="line">S = geometric_brownian_motion(S0, mu, sigma, T, dt, num_paths)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间轴</span></span><br><span class="line">time = np.linspace(<span class="number">0</span>, T, <span class="built_in">len</span>(S))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制结果</span></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制所有路径</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_paths):</span><br><span class="line">    plt.plot(time, S[:, i], linewidth=<span class="number">1</span>, alpha=<span class="number">0.7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制均值路径</span></span><br><span class="line">mean_path = np.mean(S, axis=<span class="number">1</span>)</span><br><span class="line">plt.plot(time, mean_path, <span class="string">&#x27;k--&#x27;</span>, linewidth=<span class="number">2</span>, label=<span class="string">&#x27;平均路径&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.title(<span class="string">&#x27;几何布朗运动模拟 - 股票价格路径&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;时间 (年)&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;股票价格&#x27;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>, alpha=<span class="number">0.3</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 统计分析</span></span><br><span class="line">final_prices = S[-<span class="number">1</span>, :]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;模拟结果统计:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;最终价格均值: <span class="subst">&#123;np.mean(final_prices):<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;最终价格标准差: <span class="subst">&#123;np.std(final_prices):<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;理论期望值: <span class="subst">&#123;S0 * np.exp(mu * T):<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;最低最终价格: <span class="subst">&#123;np.<span class="built_in">min</span>(final_prices):<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;最高最终价格: <span class="subst">&#123;np.<span class="built_in">max</span>(final_prices):<span class="number">.2</span>f&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="5-2-5-高级应用：期权定价"><a href="#5-2-5-高级应用：期权定价" class="headerlink" title="5.2.5 高级应用：期权定价"></a>5.2.5 高级应用：期权定价</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">european_call_option_price</span>(<span class="params">S0, K, T, r, sigma, num_simulations</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用蒙特卡洛方法计算欧式看涨期权价格&quot;&quot;&quot;</span></span><br><span class="line">    np.random.seed(<span class="number">42</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 模拟最终股价</span></span><br><span class="line">    Z = np.random.standard_normal(num_simulations)</span><br><span class="line">    ST = S0 * np.exp((r - <span class="number">0.5</span> * sigma2) * T + sigma * np.sqrt(T) * Z)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算期权收益</span></span><br><span class="line">    payoffs = np.maximum(ST - K, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算现值</span></span><br><span class="line">    option_price = np.exp(-r * T) * np.mean(payoffs)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算标准误</span></span><br><span class="line">    std_error = np.std(payoffs) / np.sqrt(num_simulations)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> option_price, std_error, payoffs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 期权参数</span></span><br><span class="line">S0 = <span class="number">100</span>    <span class="comment"># 当前股价</span></span><br><span class="line">K = <span class="number">105</span>     <span class="comment"># 行权价</span></span><br><span class="line">T = <span class="number">1.0</span>     <span class="comment"># 到期时间（年）</span></span><br><span class="line">r = <span class="number">0.03</span>    <span class="comment"># 无风险利率</span></span><br><span class="line">sigma = <span class="number">0.2</span> <span class="comment"># 波动率</span></span><br><span class="line">num_simulations = <span class="number">100000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算期权价格</span></span><br><span class="line">price, std_error, payoffs = european_call_option_price(S0, K, T, r, sigma, num_simulations)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;欧式看涨期权定价结果:&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;期权价格: <span class="subst">&#123;price:<span class="number">.4</span>f&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;标准误差: <span class="subst">&#123;std_error:<span class="number">.6</span>f&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;95% 置信区间: [<span class="subst">&#123;price - <span class="number">1.96</span>*std_error:<span class="number">.4</span>f&#125;</span>, <span class="subst">&#123;price + <span class="number">1.96</span>*std_error:<span class="number">.4</span>f&#125;</span>]&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化收益分布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.hist(payoffs, bins=<span class="number">50</span>, alpha=<span class="number">0.7</span>, edgecolor=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">plt.axvline(price * np.exp(r * T), color=<span class="string">&#x27;red&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, label=<span class="string">&#x27;平均收益&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;期权收益分布&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;收益&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;频数&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<h3 id="5-2-6-应用场景"><a href="#5-2-6-应用场景" class="headerlink" title="5.2.6 应用场景"></a>5.2.6 应用场景</h3><h4 id="5-2-6-1-金融领域"><a href="#5-2-6-1-金融领域" class="headerlink" title="5.2.6.1 金融领域"></a>5.2.6.1 金融领域</h4><ul>
<li>资产价格建模：股票、汇率等用几何布朗运动建模</li>
<li>利率模型：Vasicek模型、CIR模型描述随机变化的利率</li>
<li>信用风险：模拟违约事件的随机过程</li>
</ul>
<h4 id="5-2-6-2-通信与网络"><a href="#5-2-6-2-通信与网络" class="headerlink" title="5.2.6.2 通信与网络"></a>5.2.6.2 通信与网络</h4><ul>
<li>排队论：用泊松过程模拟顾客到达，分析网络延迟</li>
<li>流量建模：网络数据包到达的随机过程建模</li>
</ul>
<h4 id="5-2-6-3-生物与医学"><a href="#5-2-6-3-生物与医学" class="headerlink" title="5.2.6.3 生物与医学"></a>5.2.6.3 生物与医学</h4><ul>
<li>种群动力学：生物种群的随机增长和灭绝</li>
<li>疾病传播：传染病在人群中的随机扩散</li>
<li>神经科学：神经元放电的随机过程</li>
</ul>
<h4 id="5-2-6-4-物理与化学"><a href="#5-2-6-4-物理与化学" class="headerlink" title="5.2.6.4 物理与化学"></a>5.2.6.4 物理与化学</h4><ul>
<li>统计物理：分子运动、相变描述</li>
<li>化学反应动力学：分子随机碰撞和反应模拟</li>
</ul>
<h2 id="5-3-方法比较与选择"><a href="#5-3-方法比较与选择" class="headerlink" title="5.3 方法比较与选择"></a>5.3 方法比较与选择</h2><h3 id="5-3-1-特性对比"><a href="#5-3-1-特性对比" class="headerlink" title="5.3.1 特性对比"></a>5.3.1 特性对比</h3><div class="mdui-table-fluid mdui-shadow-0"><table class="mdui-table mdui-table-hoverable">
<thead>
<tr>
<th>特性</th>
<th>蒙特卡洛模拟</th>
<th>随机过程模型</th>
</tr>
</thead>
<tbody><tr>
<td>本质</td>
<td>计算方法&#x2F;技术</td>
<td>数学模型&#x2F;理论框架</td>
</tr>
<tr>
<td>核心</td>
<td>大量随机抽样求近似解</td>
<td>描述随时间演化的随机系统</td>
</tr>
<tr>
<td>关系</td>
<td>工具：用于模拟随机过程</td>
<td>对象：蒙特卡洛模拟的应用目标</td>
</tr>
<tr>
<td>数学基础</td>
<td>大数定律、中心极限定理</td>
<td>随机微积分、测度论</td>
</tr>
<tr>
<td>输出类型</td>
<td>数值结果（均值、概率）</td>
<td>随机变量序列（路径）</td>
</tr>
</tbody></table></div>
<h3 id="5-3-2-典型工作流程"><a href="#5-3-2-典型工作流程" class="headerlink" title="5.3.2 典型工作流程"></a>5.3.2 典型工作流程</h3><ol>
<li>问题定义：明确要解决的随机性问题</li>
<li>模型选择：选择合适的随机过程模型描述系统</li>
<li>参数估计：基于历史数据估计模型参数</li>
<li>模拟执行：使用蒙特卡洛方法生成大量随机路径</li>
<li>结果分析：从模拟结果中提取统计信息和洞察</li>
</ol>
<h3 id="5-3-3-实践建议"><a href="#5-3-3-实践建议" class="headerlink" title="5.3.3 实践建议"></a>5.3.3 实践建议</h3><ol>
<li>收敛性检查：增加模拟次数直到结果稳定</li>
<li>方差缩减：使用对偶变量、控制变量等技术提高效率</li>
<li>模型验证：将模拟结果与理论值或历史数据比较</li>
<li>敏感性分析：测试关键参数变化对结果的影响</li>
</ol>
<p>这两种方法共同构成了处理不确定性和随机性的强大工具箱，在科学研究、工程应用和商业决策中发挥着重要作用。</p>
<h1 id="6-数学建模中的敏感度分析：用途与方法详解"><a href="#6-数学建模中的敏感度分析：用途与方法详解" class="headerlink" title="6 数学建模中的敏感度分析：用途与方法详解"></a>6 数学建模中的敏感度分析：用途与方法详解</h1><p>敏感度分析是评估数学模型稳健性与可靠性的关键环节。它系统地探究模型输出结果如何随输入参数或假设条件的变化而改变，是模型验证、决策支持和不确定性量化不可或缺的工具。</p>
<h4 id="6-0-0-1-敏感度分析的核心用途"><a href="#6-0-0-1-敏感度分析的核心用途" class="headerlink" title="6.0.0.1 敏感度分析的核心用途"></a>6.0.0.1 敏感度分析的核心用途</h4><h4 id="6-0-0-2-识别关键驱动因素"><a href="#6-0-0-2-识别关键驱动因素" class="headerlink" title="6.0.0.2 识别关键驱动因素"></a>6.0.0.2 识别关键驱动因素</h4><p>在包含多个参数的复杂模型中，敏感度分析能够甄别出哪些参数对输出结果的影响最大。这有助于研究者抓住主要矛盾，将有限的资源和注意力集中在最需要精确估计或严格控制的因素上。<em>例如，在传染病模型中，识别出“病毒基本再生数(R0)”比“确诊后入院延迟天数”对总感染规模的影响更大。</em></p>
<h4 id="6-0-0-3-评估模型稳健性"><a href="#6-0-0-3-评估模型稳健性" class="headerlink" title="6.0.0.3 评估模型稳健性"></a>6.0.0.3 评估模型稳健性</h4><p>通过观察输出结果随输入变化的波动情况，可以判断模型的稳健性。如果一个参数的微小变动导致输出剧烈震荡，说明模型在此处非常“脆弱”，其结论的可信度较低。反之，则说明模型是稳健的，即使在输入数据存在一定误差的情况下，结论依然可靠。</p>
<h4 id="6-0-0-4-量化不确定性传递"><a href="#6-0-0-4-量化不确定性传递" class="headerlink" title="6.0.0.4 量化不确定性传递"></a>6.0.0.4 量化不确定性传递</h4><p>模型的输入参数往往来源于测量、估算或假设，本身存在不确定性。敏感度分析可以追溯这种不确定性从输入到输出的传递过程，并量化其对最终结果的影响范围。<em>例如，可以给出结论：“当成本参数在±10%范围内波动时，预期利润的波动范围为-15%至+12%。”</em></p>
<h4 id="6-0-0-5-辅助决策与优化"><a href="#6-0-0-5-辅助决策与优化" class="headerlink" title="6.0.0.5 辅助决策与优化"></a>6.0.0.5 辅助决策与优化</h4><p>在优化问题中，敏感度分析可以帮助决策者理解最优解在环境变化时的稳定性。一个对参数变化不敏感的“鲁棒解”通常比一个在精确参数下最优但参数稍变即恶化的“脆弱解”更具实践价值。</p>
<h4 id="6-0-0-6-验证与改进模型逻辑"><a href="#6-0-0-6-验证与改进模型逻辑" class="headerlink" title="6.0.0.6 验证与改进模型逻辑"></a>6.0.0.6 验证与改进模型逻辑</h4><p>如果模型输出与实证数据存在显著差异，敏感度分析可以指引调试方向。通过对高敏感参数的相关公式和假设进行重点审查，建模者可以更快地定位模型结构或逻辑上的潜在问题。</p>
<hr>
<h3 id="6-0-1-敏感度分析的主要实现方法"><a href="#6-0-1-敏感度分析的主要实现方法" class="headerlink" title="6.0.1 敏感度分析的主要实现方法"></a>6.0.1 敏感度分析的主要实现方法</h3><p>敏感度分析方法主要分为两大类：局部敏感度分析和全局敏感度分析。</p>
<h4 id="6-0-1-1-局部敏感度分析"><a href="#6-0-1-1-局部敏感度分析" class="headerlink" title="6.0.1.1 局部敏感度分析"></a>6.0.1.1 局部敏感度分析</h4><p>局部方法考察单个参数在其基准值附近发生微小变化时对输出的影响。</p>
<h4 id="6-0-1-2-偏导数法（或弹性法）"><a href="#6-0-1-2-偏导数法（或弹性法）" class="headerlink" title="6.0.1.2 偏导数法（或弹性法）"></a>6.0.1.2 偏导数法（或弹性法）</h4><ul>
<li><p>实现原理：<br>偏导数在数学上表示当其他变量固定时，一个变量的微小变化引起函数值的变化率。对于模型 $Y &#x3D; f(X_1, X_2, …, X_n)$，输出 $Y$ 对参数 $X_i$ 的敏感度可通过计算偏导数 $\frac{\partial Y}{\partial X_i}$ 来度量。其绝对值越大，表示敏感度越高。<br>为消除参数与输出值的量纲影响，通常使用弹性系数进行标准化：<br>$$\text{弹性系数} &#x3D; \frac{\partial Y &#x2F; Y}{\partial X_i &#x2F; X_i} &#x3D; \frac{\partial Y}{\partial X_i} \cdot \frac{X_i}{Y}$$</p>
<p>弹性系数表示：当参数 $X_i$ 变化 1% 时，输出 $Y$ 大约变化百分之多少。</p>
</li>
<li><p>计算示例：<br>模型： 矩形面积模型 $Area &#x3D; Length \times Width$。<br>基准值： $L_0 &#x3D; 10,m$, $W_0 &#x3D; 5,m$, $Area_0 &#x3D; 50,m^2$。</p>
<ol>
<li>计算偏导数：<br>$\frac{\partial Area}{\partial L} &#x3D; W &#x3D; 5$， $\frac{\partial Area}{\partial W} &#x3D; L &#x3D; 10$。<br>在基准点附近，长度每增加1米，面积增加5平方米；宽度每增加1米，面积增加10平方米。初步判断面积对宽度更敏感。</li>
<li>计算弹性系数：<ul>
<li>对于长度 $L$：弹性系数 &#x3D; $\frac{\partial Area}{\partial L} \cdot \frac{L_0}{Area_0} &#x3D; 5 \times \frac{10}{50} &#x3D; 1$。</li>
<li>对于宽度 $W$：弹性系数 &#x3D; $\frac{\partial Area}{\partial W} \cdot \frac{W_0}{Area_0} &#x3D; 10 \times \frac{5}{50} &#x3D; 1$。<br>通过弹性系数分析发现，当长度或宽度各自增加1%时，面积均增加1%。在该线性模型中，两者重要性相当。此例展示了标准化的重要性。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="6-0-1-3-“一次一个变量”（OAT）法"><a href="#6-0-1-3-“一次一个变量”（OAT）法" class="headerlink" title="6.0.1.3 “一次一个变量”（OAT）法"></a>6.0.1.3 “一次一个变量”（OAT）法</h4><ul>
<li><p>实现原理：<br>此方法是偏导数概念的数值近似，无需微积分知识，易于操作。</p>
<ol>
<li>设定所有参数的基准值，并计算得到基准输出 $Y_0$。</li>
<li>选定一个变化比例 $p$（通常为±5%, ±10%等）。</li>
<li>对于每一个参数 $X_i$，将其值变为 $X_i \times (1 + p)$，而保持其他所有参数不变，计算得到新输出 $Y_i^+$。</li>
<li>计算该参数变化导致的输出绝对变化量 $\Delta Y_i &#x3D; Y_i^+ - Y_0$ 或相对变化量 $(\Delta Y_i &#x2F; Y_0) \times 100%$。</li>
<li>比较所有参数的输出变化量，变化量越大，该参数越敏感。</li>
</ol>
</li>
<li><p>计算示例：<br>模型： 项目利润模型 $Profit &#x3D; Revenue - Cost &#x3D; (Price \times Volume) - (Fixed\ Cost + Variable\ Cost \times Volume)$。<br>基准值： $Price &#x3D; 100$, $Volume &#x3D; 1000$, $Fixed\ Cost &#x3D; 20000$, $Variable\ Cost &#x3D; 50$。<br>基准利润 $P_0 &#x3D; (100 \times 1000) - (20000 + 50 \times 1000) &#x3D; 100000 - 70000 &#x3D; 30000$。<br>现进行+10%的OAT分析：</p>
<div class="mdui-table-fluid mdui-shadow-0"><table class="mdui-table mdui-table-hoverable">
<thead>
<tr>
<th align="left">参数</th>
<th align="left">基准值</th>
<th align="left">变化后值</th>
<th align="left">新利润</th>
<th align="left">绝对变化</th>
<th align="left">相对变化</th>
<th align="left">敏感度排名</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Price</td>
<td align="left">100</td>
<td align="left">110</td>
<td align="left">40000</td>
<td align="left">+10000</td>
<td align="left">+33.3%</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">Volume</td>
<td align="left">1000</td>
<td align="left">1100</td>
<td align="left">35000</td>
<td align="left">+5000</td>
<td align="left">+16.7%</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">Variable Cost</td>
<td align="left">50</td>
<td align="left">55</td>
<td align="left">25000</td>
<td align="left">-5000</td>
<td align="left">-16.7%</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">Fixed Cost</td>
<td align="left">20000</td>
<td align="left">22000</td>
<td align="left">28000</td>
<td align="left">-2000</td>
<td align="left">-6.7%</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">结论：利润对售价的变化最敏感，其次是销量和变动成本，对固定成本最不敏感。</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table></div>
</li>
</ul>
<h4 id="6-0-1-4-全局敏感度分析"><a href="#6-0-1-4-全局敏感度分析" class="headerlink" title="6.0.1.4 全局敏感度分析"></a>6.0.1.4 全局敏感度分析</h4><p>全局方法允许所有参数在其整个可能取值范围内同时变化，从而全面评估每个参数的主效应以及参数之间的相互作用。</p>
<h4 id="6-0-1-5-蒙特卡洛模拟与回归分析法"><a href="#6-0-1-5-蒙特卡洛模拟与回归分析法" class="headerlink" title="6.0.1.5 蒙特卡洛模拟与回归分析法"></a>6.0.1.5 蒙特卡洛模拟与回归分析法</h4><ul>
<li><p>实现原理：</p>
<ol>
<li>定义分布： 为每个输入参数定义一个概率分布以描述其不确定性（例如，均值为基准值，范围±10%的均匀分布）。</li>
<li>随机抽样： 从这些联合分布中利用计算机随机生成 $N$ 组参数样本（$N$ 通常很大，如10000）。</li>
<li>运行模型： 将这 $N$ 组参数逐一代入模型，得到 $N$ 个对应的输出值 $Y$。</li>
<li>构建回归模型： 以所有输入参数为自变量，模型输出 $Y$ 为因变量，构建一个多元线性回归模型：$Y &#x3D; \beta_0 + \beta_1X_1 + \beta_2X_2 + … + \beta_nX_n + \epsilon$。</li>
<li>计算敏感度指标：<ul>
<li>标准化回归系数（SRC）： 将原始数据和输出值进行标准化（减去均值，除以标准差）后得到的回归系数 $\beta_i^<em>$。$\beta_i^</em>$ 的绝对值越大，表明参数 $X_i$ 对输出 $Y$ 的影响越大。</li>
<li>决定系数（R²）： 该回归模型的R²值表示输入参数共同解释了输出总方差的多少比例。</li>
</ul>
</li>
</ol>
</li>
<li><p>计算示例：<br>模型： 同上文的利润模型。<br>步骤：</p>
<ol>
<li>假设四个参数均服从在其基准值±10%范围内的均匀分布。</li>
<li>使用软件（如Python, R, Excel）生成10000组随机参数组合。</li>
<li>计算10000个利润值。</li>
<li>对数据进行多元线性回归，得到标准化回归系数（SRC）。<br>假设结果为：Price的SRC &#x3D; 0.65, Volume的SRC &#x3D; 0.35, Variable Cost的SRC &#x3D; -0.35, Fixed Cost的SRC &#x3D; -0.10。<br>结论： 价格的SRC绝对值最大(0.65)，是影响利润的最关键因素。销量和变动成本影响力相当且次之。固定成本影响最小。该结果与OAT分析一致，但基于全局评估，更具统计意义。</li>
</ol>
</li>
</ul>
<h4 id="6-0-1-6-Morris筛选法"><a href="#6-0-1-6-Morris筛选法" class="headerlink" title="6.0.1.6 Morris筛选法"></a>6.0.1.6 Morris筛选法</h4><ul>
<li><p>实现原理：<br>Morris法是一种高效的全局筛选方法，旨在以较少的计算成本识别出重要参数。</p>
<ol>
<li>参数空间离散化： 将每个参数的取值范围离散化为 $p$ 个水平。</li>
<li>生成轨迹： 在参数空间中随机生成一条“轨迹”。轨迹由 $k+1$ 个点组成（$k$ 为参数个数），每个点与前一个点只在一个参数的取值上不同。</li>
<li>计算基本效应： 对于轨迹上的每一步变化（即某个参数 $X_i$ 的变化），计算其“基本效应”（Elementary Effect, EE）：<br>$$EE_i &#x3D; \frac{Y(X_1, …, X_i + \Delta, …, X_k) - Y(X_1, …, X_i, …, X_k)}{\Delta}$$<br>其中 $\Delta$ 是预先设定的变化步长。</li>
<li>重复与统计： 独立生成 $r$ 条轨迹（例如20-50条），从而对每个参数得到 $r$ 个基本效应。</li>
<li>分析指标： 对每个参数 $X_i$，计算其 $r$ 个基本效应的均值 $\mu_i$ 和标准差 $\sigma_i$。<ul>
<li>均值 $\mu_i$：衡量参数对输出的总体影响。绝对值越大越重要。</li>
<li>标准差 $\sigma_i$：衡量参数非线性效应或交互作用的强度。值越大，说明该参数的影响依赖于其他参数的取值。</li>
</ul>
</li>
</ol>
</li>
<li><p>计算示例：<br>考虑一个简单的非线性模型 $Y &#x3D; X_1 + 2X_2 + X_1X_3$，假设有3个参数。</p>
<ol>
<li>生成 $r&#x3D;4$ 条Morris轨迹，计算每个参数的基本效应。</li>
<li>假设得到以下统计结果：<div class="mdui-table-fluid mdui-shadow-0"><table class="mdui-table mdui-table-hoverable">
<thead>
<tr>
<th align="left">参数</th>
<th align="left">基本效应均值 $\mu$</th>
<th align="left">基本效应标准差 $\sigma$</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$X_1$</td>
<td align="left">中</td>
<td align="left">高</td>
</tr>
<tr>
<td align="left">$X_2$</td>
<td align="left">高</td>
<td align="left">低</td>
</tr>
<tr>
<td align="left">$X_3$</td>
<td align="left">低</td>
<td align="left">高</td>
</tr>
<tr>
<td align="left">结论：</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table></div>
</li>
</ol>
<ul>
<li>$X_2$ 的 $\mu$ 高且 $\sigma$ 低，表明它是一个具有稳定、强大线性影响的关键参数。</li>
<li>$X_1$ 的 $\mu$ 中等但 $\sigma$ 高，表明其影响大小不稳定，依赖于其他参数（这与公式中 $X_1$ 与 $X_3$ 存在交互项 $X_1X_3$ 相符）。</li>
<li>$X_3$ 的 $\mu$ 低但 $\sigma$ 高，表明其单独影响小，但通过与其他参数（$X_1$）的交互作用产生影响。</li>
</ul>
</li>
</ul>
<h4 id="6-0-1-7-基于方差的方法（Sobol’法）"><a href="#6-0-1-7-基于方差的方法（Sobol’法）" class="headerlink" title="6.0.1.7 基于方差的方法（Sobol’法）"></a>6.0.1.7 基于方差的方法（Sobol’法）</h4><ul>
<li><p>实现原理：<br>Sobol’法是一种基于方差的、最彻底的全局敏感度分析方法。它将模型输出的总方差 $V(Y)$ 分解为各个参数及其相互作用的贡献之和。</p>
<ol>
<li>方差分解： $V(Y) &#x3D; \sum_i V_i + \sum_{i&lt;j} V_{ij} + \sum_{i&lt;j&lt;k} V_{ijk} + … + V_{12…k}$<ul>
<li>$V_i$ 是仅由 $X_i$ 引起的主效应方差。</li>
<li>$V_{ij}$ 是由 $X_i$ 和 $X_j$ 的交互作用引起的方差，以此类推。</li>
</ul>
</li>
<li>计算敏感度指数：<ul>
<li>一阶索博尔指数（主效应指数）： $S_i &#x3D; \frac{V_i}{V(Y)}$。表示仅由 $X_i$ 自身变化所贡献的输出方差比例。</li>
<li>总效应索博尔指数： $S_{Ti} &#x3D; S_i + \sum_{j \neq i} S_{ij} + …$。表示 $X_i$ 及其与所有其他参数的交互作用共同贡献的输出方差比例。</li>
</ul>
</li>
<li>实现步骤： 通过构造两套特定的样本矩阵（如A、B矩阵）并运行模型，利用蒙特卡洛积分来估算这些方差项和指数。</li>
</ol>
</li>
<li><p>计算示例：<br>假设对一个复杂的环境模型进行Sobol‘分析，得到以下结果：</p>
<div class="mdui-table-fluid mdui-shadow-0"><table class="mdui-table mdui-table-hoverable">
<thead>
<tr>
<th align="left">参数</th>
<th align="left">一阶指数 $S_i$</th>
<th align="left">总效应指数 $S_{Ti}$</th>
</tr>
</thead>
<tbody><tr>
<td align="left">温度 (T)</td>
<td align="left">0.15</td>
<td align="left">0.20</td>
</tr>
<tr>
<td align="left">湿度 (H)</td>
<td align="left">0.40</td>
<td align="left">0.45</td>
</tr>
<tr>
<td align="left">风速 (W)</td>
<td align="left">0.05</td>
<td align="left">0.25</td>
</tr>
<tr>
<td align="left">深度解读：</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table></div>
<ul>
<li>湿度 (H) 的一阶指数(0.4)和总效应指数(0.45)都最高且接近，表明它是最重要且影响独立的参数。</li>
<li>温度 (T) 的一阶指数(0.15)和总效应指数(0.20)存在一定差距，表明它有一定的重要性，并存在轻微的交互作用。</li>
<li>风速 (W) 的一阶指数(0.05)很低，但总效应指数(0.25)很高。这是一个关键发现：风速单独变化时影响很小，但它通过与其他参数（如T和H）的强烈交互作用，对输出方差产生了重要影响。这是OAT和回归分析法难以发现的。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-0-2-总结与方法选择建议"><a href="#6-0-2-总结与方法选择建议" class="headerlink" title="6.0.2 总结与方法选择建议"></a>6.0.2 总结与方法选择建议</h3><div class="mdui-table-fluid mdui-shadow-0"><table class="mdui-table mdui-table-hoverable">
<thead>
<tr>
<th align="left">方法类别</th>
<th align="left">核心思想</th>
<th align="left">优点</th>
<th align="left">缺点</th>
<th align="left">适用阶段</th>
</tr>
</thead>
<tbody><tr>
<td align="left">局部（OAT&#x2F;偏导）</td>
<td align="left">单参数在基准点微小变动</td>
<td align="left">计算快，简单直观</td>
<td align="left">忽略交互作用，依赖基准点</td>
<td align="left">初步、快速分析</td>
</tr>
<tr>
<td align="left">全局（Morris）</td>
<td align="left">多参数在全局范围内变动筛选</td>
<td align="left">效率高，适合参数筛选，能揭示非线性&#x2F;交互</td>
<td align="left">只能排序，无法精确量化方差贡献</td>
<td align="left">前期，参数众多时（&gt;10）</td>
</tr>
<tr>
<td align="left">全局（蒙特卡洛回归）</td>
<td align="left">多参数同时随机变动</td>
<td align="left">概念简单，可图形化，提供统计指标</td>
<td align="left">对强非线性&#x2F;交互作用解释力下降</td>
<td align="left">中期，一般性全局分析</td>
</tr>
<tr>
<td align="left">全局（Sobol’）</td>
<td align="left">将输出方差分解到各参数</td>
<td align="left">结果最全面、精确，能分离主效应和交互效应</td>
<td align="left">计算成本极高</td>
<td align="left">后期，深入、精确分析</td>
</tr>
</tbody></table></div>
<h4 id="6-0-2-1-选择建议："><a href="#6-0-2-1-选择建议：" class="headerlink" title="6.0.2.1 选择建议："></a>6.0.2.1 选择建议：</h4><p>在实际建模中，推荐采用“由粗到精”的递进策略：</p>
<ol>
<li>参数众多时：首先使用 Morris筛选法，快速锁定少数关键参数。</li>
<li>深入分析关键参数：对筛选出的关键参数（通常少于10个），使用 Sobol‘法 进行精确的方差贡献分析，明确主效应和交互效应。</li>
<li>简单模型或快速评估：对于线性模型或仅需概览时，局部OAT法 或 蒙特卡洛回归法 是高效且足够的选择。</li>
</ol>
<p>严谨的敏感度分析是模型构建过程中体现科学性与可靠性的基石，其结论能极大地增强模型输出的说服力和决策支持价值。</p>

        
        <blockquote class="mdui-m-x-0 mdui-m-t-4">
    <strong>
        作者：<a href="/Old-Blogs/about/">Random-spike</a><br>
        链接：<a href="https://random-spike.github.io/Old-Blogs/001_%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B8%8E%E7%90%86%E8%AE%BA/">https://random-spike.github.io/Old-Blogs/001_%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E4%B8%8E%E7%90%86%E8%AE%BA/</a><br>
        
            本文采用 <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> 进行许可。
        
    </strong>
</blockquote>
        
    </div>
    
</article>
<nav class="mdui-theme-layout-light mdui-color-transparent mdui-row mdui-m-b-2">
    
        <div class="mdui-col-xs-12 mdui-m-b-2">
            <span disabled class="extend prev mdui-btn mdui-ripple mdui-float-left" rel="prev">
                <i class="mdui-icon mdui-icon-left material-icons">arrow_back</i>
            </span>
        </div>
    
        <div class="mdui-col-xs-12">
            <a class="extend next mdui-btn mdui-ripple mdui-float-right mdui-text-truncate" rel="next"
                style="max-width: 100%" href="/Old-Blogs/002_%E5%AD%A6%E5%86%9C%E5%AE%9E%E5%BD%95/">
                <i class="mdui-icon mdui-icon-right material-icons">arrow_forward</i>学农实录
            </a>
        </div>
    
</nav>

    </div>
    <a href="#" class="mdui-fab mdui-fab-fixed mdui-hidden-xs mdui-color-theme-accent mdui-ripple"><i class="mdui-icon material-icons">keyboard_arrow_up</i></a>

<script src="https://cdn.jsdelivr.net/npm/mdui@1.0.2/dist/js/mdui.min.js"></script>


<script>
    var $ = mdui.$;
    function init(){
        //
    }
    window.addEventListener("load", () => {
        //
        init()
    }, {once: true});
</script>

</body>
</html>